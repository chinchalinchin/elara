
<!DOCTYPE html>


<html lang="en" data-content_root="../" data-theme="dark">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Section I: Language &#8212; elara protocol</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "dark";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "dark";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '04_palindromia/02_language';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Section II: Corpora" href="03_corpora.html" />
    <link rel="prev" title="Palindromic Structures" href="01_introduction.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="dark">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">elara protocol</p>
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../01_organon/index.html">Organon</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../01_organon/00_cantor.html">Cantor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../01_organon/01_peano.html">Peano</a></li>
<li class="toctree-l2"><a class="reference internal" href="../01_organon/02_tarski.html">Tarski</a></li>
<li class="toctree-l2"><a class="reference internal" href="../01_organon/03_zalta.html">Zalta</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../02_facticity/index.html">Facticity</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../02_facticity/00_ante_christum.html">Ante Christum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_facticity/01_anno_domini.html">Anno Domini</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_facticity/02_aidion.html">·ºÄŒØŒ¥ŒπŒøŒΩ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02_facticity/03_kairos.html">Œ∫Œ±ŒπœÅœåœÇ</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../03_universalis/index.html">Universalis</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../03_universalis/modules/index.html">Modules</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/modules/M01_meta.html">Module: Meta Grammar</a></li>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/modules/M02_object.html">Module: Object</a></li>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/modules/M03_voice.html">Module: Voice</a></li>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/modules/M04_inflection.html">Module: Inflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/modules/M05_words.html">Module V: Words</a></li>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/modules/M06_rhythm.html">Module: Rhythm</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../03_universalis/plugins/index.html">Plugins</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/plugins/P01_initialization.html">Plugin I: Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/plugins/P02_adaptation.html">Plugin III: Adaptation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/plugins/P03_functions.html">Plugin IV: Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/plugins/P04_metrics.html">Plugin V: Metrics</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../03_universalis/games/index.html">Games</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/games/G01_exercises.html">Games I: Exercises</a></li>
<li class="toctree-l3"><a class="reference internal" href="../03_universalis/games/G02_garden.html">Game II: The Garden</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">Palindromia</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="00_glossary.html">Glossary</a></li>
<li class="toctree-l2"><a class="reference internal" href="01_introduction.html">Palindromic Structures</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Section I: Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="03_corpora.html">Section II: Corpora</a></li>
<li class="toctree-l2"><a class="reference internal" href="04_structures.html">Section III: Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="05_palindromes.html">Section IV: Palindromes</a></li>
<li class="toctree-l2"><a class="reference internal" href="06_analysis.html">Section V: Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="07_postulates.html">Section VI.III: Postulates</a></li>
<li class="toctree-l2"><a class="reference internal" href="08_appendix.html">Section VII: Appendix</a></li>
<li class="toctree-l2"><a class="reference internal" href="09_data.html">Section VIII: Data</a></li>


<li class="toctree-l2"><a class="reference internal" href="10_app.html">Section VIII: Code</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../05_poeticus/index.html">Poeticus</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../05_poeticus/00_form.html">Form</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../06_pedagogy/index.html">Pedagogy</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../06_pedagogy/foundations/index.html">Foundations</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/foundations/00_HISTORY.html">Knowledge</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/foundations/01_LOGIC.html">Logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/foundations/02_SET_THEORY.html">Set Theory</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../06_pedagogy/probability/index.html">Probability</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/probability/00_INTRODUCTION.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/probability/01_COMBINATORICS.html">Combinatorics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/probability/02_CONDITIONAL.html">Conditional Probability</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/probability/03_RANDOM_VARIABLES.html">Random Variables</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../06_pedagogy/statistics/index.html">Statistics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/statistics/00_GRAPHS.html">Graphical Representations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/statistics/01_ESTIMATION.html">Point Estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/statistics/02_CORRELATION.html">Correlation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/statistics/03_REGRESSION.html">Linear Regression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/statistics/04_SAMPLING.html">Sampling Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/statistics/05_CONFIDENCE.html">Confidence Intervals</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../06_pedagogy/distributions/index.html">Distributions</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/distributions/00_BERNOULLI.html">Bernoulli Distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/distributions/01_GEOMETRIC.html">Geometric Distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/distributions/02_BINOMIAL.html">Binomial Distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/distributions/03_UNIFORM.html">Uniform Distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/distributions/04_NORMAL.html">Normal Distribution</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../06_pedagogy/inference/index.html">Inference</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/inference/00_INTRODUCTION.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/inference/01_BIAS.html">Statistical Bias</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/inference/02_DESIGN.html">Experimental Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/inference/03_HYPOTHESES.html">Hypothesis Testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/inference/04_MEAN.html">Population Mean</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/inference/05_PROPORTION.html">Population Proportion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../06_pedagogy/inference/06_VARIANCE.html">Population Standard Deviation</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../radix.html">Radix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../matrix.html">Matrix</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/04_palindromia/02_language.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Section I: Language</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#section-i-i-strings">Section I.I: Strings</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#characters">Characters</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#concatenation">Concatenation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#string-length">String Length</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#containment">Containment</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#section-i-ii-words">Section I.II: Words</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theorems">Theorems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#string-inversion">String Inversion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phrases">Phrases</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#section-i-iii-word-classes">Section I.III: Word Classes</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reflective-words">Reflective Words</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#invertible-words">Invertible Words</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="section-i-language">
<span id="section-i"></span><h1>Section I: Language<a class="headerlink" href="#section-i-language" title="Link to this heading">#</a></h1>
<p>Some general notation adopted throughout the course of this work is given below.</p>
<ol class="arabic simple">
<li><p><strong>N</strong><sub>n</sub> will represent the set of natural numbers starting at 1 and ending at <em>n</em>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[N_n = \{ 1, 2, ... , n \}\]</div>
<ol class="arabic simple" start="2">
<li><p>The cardinality of a set <strong>A</strong> will be denoted <span class="math notranslate nohighlight">\(\lvert A \rvert\)</span></p></li>
<li><p>The ‚àé symbol will be used to denote the ending of all Definitions, Examples and Proofs.</p></li>
<li><p>The terms <em>‚Äúset‚Äù</em> and <em>‚Äúclass‚Äù</em> are used interchangeably.</p></li>
</ol>
<section id="section-i-i-strings">
<span id="section-i-i"></span><h2>Section I.I: Strings<a class="headerlink" href="#section-i-i-strings" title="Link to this heading">#</a></h2>
<p>The domain of discourse is composed of <em>Strings</em>. A String will be represented as follows,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>String (<em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, <em>s</em><sub>3</sub>): A lowercase English <em>s</em> with a subscript denotes a String. Often the subscript will be dropped and <em>s</em> will be used. The letter <em>t</em>, <em>u</em>, <em>v</em> and <em>w</em> are also reserved for Strings.</p></li>
</ol>
</div></blockquote>
<p>A String is regarded as a linguistic artifact that is defined by its <em>length</em>, its <em>Characters</em> and their <em>ordering</em>. It is assumed if one knows how many Characters are in a String, which Characters are in a String and in what order they occur, then one has all the information necessary to completely determine the String. This notion is made more precise below with the introduction of several core definitions.</p>
<p>The set of all Strings is denoted <strong>S</strong>. At this point, nothing definitive can be asserted about the contents or cardinality of <strong>S</strong>. Once Characters are introduced and concatenation is defined, it will be possible to make claims regarding <strong>S</strong>.</p>
<p>The goal is to define all linguistics entities over the set of all Strings: Characters, Alphabets, Words, Languages, Sentences and Corpuses. As each of these entities is introduced and defined, a new level of relations will reveal itself. Palindromic symmetries will manifest on each level, in slightly different but related forms. Each type of symmetry will involve, in some form or another, the concept of <em>String Inversion</em>, to be defined shortly. The essence of a Palindrome lies in binding together the syntactical symmetries at every linguistic layer into a semantic whole. Indeed, it will be seen the symmetrical structure required by Palindromes in turn requires these linguistic layers to have specific synactical properties, regardless of their semantic interpretation.</p>
<p>A <em>Word</em> will be considered a <em>type</em> of String. Colloquially, a Word can be understood as a String with semantic content. The goal of this section is to describe the necessary syntactic conditions for a String to be considered a formal Word, without taking into account the semantic content that is assigned to it through everyday use. In other words, the analysis assumes Words have already been selected from the set of all possible Strings and assigned interpretations.</p>
<section id="characters">
<span id="id1"></span><h3>Characters<a class="headerlink" href="#characters" title="Link to this heading">#</a></h3>
<p>A <em>Character</em> is the basic unit of a String. Characters will be represented as follows,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Characters (<em>ùîû</em>, <em>ùîü</em>,  <em>ùî†</em>, etc. ): Lowercase Fraktur letters represent Characters. Subscripts will occassionally be used in conjunction with Fraktur letters to denote Characters at specific positions within Strings, (<em>ùîû</em><sub>1</sub>, <em>ùîû</em><sub>2</sub>, ‚Ä¶ ).</p></li>
<li><p>Empty (<em>Œµ</em>): The lowercase Greek letter epsilon, <em>Œµ</em>, represents the Empty Character.</p></li>
<li><p>Delimiter (<em>œÉ</em>): The lowercase Greek letter sigma, <em>œÉ</em>, represents the Delimiter Character.</p></li>
</ol>
</div></blockquote>
<p>In the case of English, Characters would correspond to letters such as ‚Äúa‚Äù, ‚Äúb‚Äù, ‚Äúc‚Äù, etc., the Empty Character would correspond to the null letter, ‚Äú‚Äù, and the Delimiter Character would correpond to the blank letter, ‚Äú ‚Äú.</p>
<p>The exact meaning of these symbols should be attended with utmost care. <em>ùîû</em>, <em>ùîü</em>,  <em>ùî†</em>, etc., represent Characters of the Alphabet and thus are all unique, each one representing a different linguistic element. When Character symbols are used with subscripts, <em>ùîû</em><sub>1</sub>, <em>ùîû</em><sub>2</sub>, etc., they are being referenced in their capacity to be ordered within a String. With this notation, it is not necessarily implied <em>ùîû</em><sub>1</sub> and <em>ùîû</em><sub>2</sub> are unequal Character-wise, but that they are differentiated only by their relative order in a String.</p>
<p>The Empty Character also deserves special mention, since it represents a <em>null</em> Character. The Empty Character is to be understood as a Character with no semantic content. It can be added or subtracted from a String without altering it in any way. The domain of all Strings <strong>S</strong>, as will be shown in (the albeit informal) <a class="reference internal" href="#theorem-1-1-2"><span class="std std-ref">Theorem 1.1.2</span></a>, is uncountably infinite. Beyond this, the Empty Character introduces further ambiguity when defining the concepts of Word and Language, since multiple Strings with the Empty Character, i.e. <em>ùîûŒµ</em>, <em>ùîûŒµŒµ</em>, <em>ùîûŒµŒµŒµ</em>, etc., can represent the same semantic content. In order to formally define these linguistic entities, the Empty Character must be excluded from the domain of Words and Language.</p>
<p>Take note, at this point it is has not yet been shown that Characters are Strings; the preceding statements should be taken heuristically. This will be rectified in the next section with the formal definition of concatenation and the introduction of <a class="reference internal" href="#axiom-c1"><span class="std std-ref">Character Axiom C.1</span></a>.</p>
<p>The aggregate of all Characters is called an <em>Alphabet</em> and is denoted by an uppercase Sigma, <span class="math notranslate nohighlight">\(\Sigma\)</span>,</p>
<div class="math notranslate nohighlight">
\[\Sigma = \{ \varepsilon, \sigma, \mathfrak{a}, \mathfrak{b}, \mathfrak{c}, ... \}\]</div>
<p>It will sometimes be necessary to refer to indeterminate Characters, so notation is introduced for Character Variables,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Character Variables (<em>Œπ</em>, <em>ŒΩ</em>, <em>Œø</em>, <em>œÅ</em>, ): The Lowercase Greek letters Rho, Omicron, Iota and Nu will represent Character Variables, i.e. indeterminate Characters. Subscripts will occassionally be used with Iota to denote Word Variables, (<em>Œπ</em><sub>1</sub>, <em>Œπ</em><sub>2</sub>, ‚Ä¶ )</p></li>
</ol>
</div></blockquote>
<p>Once again, it should be noted when Character Variables are used with subscripts, it is meant to refer to the capacity of a Character Variable to be indeterminate at a <em>determinate position</em> within a String. Moreover, the range of a Character Variable is understood to be the Alphabet <span class="math notranslate nohighlight">\(\Sigma\)</span> from which it is being drawn.</p>
<p>At this early stage, the formal system needs to introduce a notion of <em>equality</em> to make any significant headway. There will be a several types of equality defined within the system, but each new layer of equality will be built on top of the primitive notion of <em>Character Equalty</em> now introduced in the first preliminary Axiom to the formal system.</p>
<p id="axiom-c0"><strong>Axiom C.0: The Equality Axiom</strong></p>
<p>For any Characters <span class="math notranslate nohighlight">\(\iota, \nu \in \Sigma\)</span>, the notion of equality, denoted by <span class="math notranslate nohighlight">\(\iota = \nu\)</span>, is a primitive concept and assumed to be understood. It is further assumed that Character Equality is an equivalence relation, satisfying reflexivity, symmetry and transitivity,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\forall \iota \in \Sigma : \iota = \iota\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\forall \iota, \nu \in \Sigma : \iota = \nu \leftrightarrow \nu = \iota\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\forall \iota, \nu, \omicron \in \Sigma : (\iota = \nu \land \nu = \omicron) \to (\iota = \omicron)\)</span></p></li>
</ol>
</div></blockquote>
<p>‚àé</p>
<p>Character Equality will be used to define <em>String Equality</em> in <a class="reference internal" href="#definition-1-1-4"><span class="std std-ref">Definition 1.1.4</span></a> and Word Equality in <a class="reference internal" href="#definition-1-2-3"><span class="std std-ref">Definition 1.2.3</span></a>.</p>
</section>
<section id="concatenation">
<span id="id2"></span><h3>Concatenation<a class="headerlink" href="#concatenation" title="Link to this heading">#</a></h3>
<p>Concatenation is considered the sole constitutive operation for the formation of Strings. It is taken as a primitive operation, but not an elementary operation. By this it is meant the notion of concatenation that is about to be adopted does not define concatenation solely in terms of Strings. Concatenation will be defined as a hetergeneous operation that is performed between Characters in a Alphabet and Strings.</p>
<p id="definition-1-1-1"><strong>Definition 1.1.1: Concatenation</strong></p>
<p>The result of <em>concatenating</em> any two Characters <em>Œπ</em> and <em>ŒΩ*</em> is denoted <em>ŒπŒΩ</em>. To make the operands of concatenation clear, parenthesis will sometimes be used to separate the Characters being concatenated, e.g. <em>Œπ(ŒΩ) = (Œπ)ŒΩ = (Œπ)(ŒΩ) = ŒπŒΩ</em>. Character concatenation is defined inductively through the following schema,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Basic Clause: <span class="math notranslate nohighlight">\(\forall \iota \in \Sigma : \iota \varepsilon = \iota\)</span></p></li>
<li><p>Inductive Clause: <span class="math notranslate nohighlight">\(\forall \iota, \nu \in \Sigma : \forall s \in S: \iota(\nu s) = (\iota \nu)s\)</span></p></li>
<li><p>Uniqueness Clause: <span class="math notranslate nohighlight">\(\forall \iota, \nu, \omicron, \rho \in \Sigma : (\iota \nu = \omicron \rho) \to ((\iota = \omicron) \land (\nu = \rho))\)</span></p></li>
<li><p>Comprehension Clause: <span class="math notranslate nohighlight">\(\forall \iota \in \Sigma : \forall s \in S: \iota \in S\)</span></p></li>
</ol>
</div></blockquote>
<p>‚àé</p>
<p>Colloquially, <em>ŒπŒΩ</em> is the String that results from placing <em>ŒΩ</em> behind <em>Œπ</em>.</p>
<p>The first clause in <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a> is the basis step of induction which states any Character appended to the Empty Character is the Character itself. The second clause is the inductive step which allows the concatenation of Characters of arbitrary length into Strings through recursion.</p>
<p>The Uniqueness Clause states that if the concatenation of two characters <em>Œπ</em> and <em>ŒΩ</em> is equal to the concatenation of two other characters <em>Œø</em> and <em>œÅ</em>, then it must be the case that <em>Œπ</em> is equal to <em>Œø</em> and <em>ŒΩ</em> is equal to <em>œÅ</em>. In other words, there‚Äôs only one set of Characters that can form a given String through concatenation.</p>
<p>It is assumed that the operation of concatenation is closed with respect to the set of all Strings <strong>S</strong>. In other words, concatenation will always yield a String. This assumption is partly captured in the Comprehension Clause of <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a>. This clause ensures that the result of concatenating any Character with a String is a String. However, this clause in and of itself does not ensure the closure of <strong>S</strong> with respect to concatenation. In order to close <strong>S</strong> over concatenation, an additional assumption must be introduced. Before introducing this assumption in the form of an axiom, a brief explanation is required for this departure from convention.</p>
<p>Concatenation as it is normally found in the fields of automata theory or regular expressions is treated as a primitive operation performed between two string operands. Concatenation of multiple strings is then defined inductively, similary to <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a> but differing in the essential quality that it treats of only strings. The current formulation differs in that concatenation in this system is not conceived, at least in the primitive stage, as the ‚Äújoining‚Äù of two or more Strings. Instead, the formal system under construction treats concatenation as an elementary operation that occurs between Characters and Strings, i.e. it is a <em>hetergeneous</em> operation.</p>
<p>The reason for this distinction will become clear as the formal theory begins to detail palindromic structures that display symmetry across linguistic levels. It should only be noted at this point that <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a> is a conscious decision to depart from convention.</p>
<p>To make this distinction plain, consider that given an Alphabet <span class="math notranslate nohighlight">\(\Sigma\)</span> and <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a>, one still cannot say the result of a concatenation of two Characters is a String, nor make any claim about the contents of <span class="math notranslate nohighlight">\(S\)</span>, the set of all Strings. The Comprehension Clause of <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a> only states the result of concatenating a Character with a String is a String. It says nothing at all about whether or not single Characters themselves are Strings, and thus it says nothing about whether the result of concatenating two or more Characters is itself a String.</p>
<p>In order to rectify this, the first (official) Axiom is now introduced.</p>
<p id="axiom-c1"><strong>Axiom C.1: The Character Axiom</strong></p>
<div class="math notranslate nohighlight">
\[\forall \iota \in \Sigma: \iota \in S\]</div>
<p>This Axiom states the intuitive notion that all Characters are Strings. This includes Empty Characters and Delimiter Characters. This Axiom, in conjunction with <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a>, immediately populates the set of all Strings <strong>S</strong> with an uncountably infinite domain of objects (See <a class="reference internal" href="#theorem-1-1-2"><span class="std std-ref">Theorem 1.1.2</span></a> for an informal proof of this fact) consisting of every possible combination of Characters from the Alphabet, in every possible order. In other words, <a class="reference internal" href="#axiom-c1"><span class="std std-ref">Axiom C.1</span></a> in conjunction with <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a> ensure the domain is non-Empty.</p>
<p><strong>Example</strong> Let <em>s = ùîûùîüùî†</em> and <em>t = ùî°ùî¢ùî£</em>. The concatenation of these two Strings <em>st</em> is written,</p>
<div class="math notranslate nohighlight">
\[st = (\mathfrak{abc})(\mathfrak{def})\]</div>
<p>Using the inductive clause, this concatenation can be grouped into simpler concatenations as follows,</p>
<div class="math notranslate nohighlight">
\[\mathfrak{a}(\mathfrak{b}(\mathfrak{c}(\mathfrak{d}(\mathfrak{ef})))) = (((((\mathfrak{ab})\mathfrak{c})\mathfrak{d})\mathfrak{e})\mathfrak{f}) = \mathfrak{abcdef}\]</div>
<p>Therefore, <em>st = ùîûùîüùî†ùî°ùî¢ùî£</em> ‚àé</p>
</section>
<section id="string-length">
<span id="id3"></span><h3>String Length<a class="headerlink" href="#string-length" title="Link to this heading">#</a></h3>
<p>It will sometimes be convenient to represent Strings as ordered sets of Characters, rather than serialized concatenations of Characters. The two formulations are equivalent, but the set representation has advantages when it comes to quantification and symbolic logic. When a String or Word representation is intended to be interpretted as a set, it will be written in bold uppercase letters. For example, the String represented as the concatenation <em>s</em><sub>1</sub> <em>= ùîûùîüùî†</em> would be represented in this formulation as a set of ordered pairs <strong>S</strong><sub>1</sub>, where the first coordinate encodes the position of the Character in the String,</p>
<div class="math notranslate nohighlight">
\[S_1 = \{ (1, \mathfrak{a}), (2, \mathfrak{b}), (3, \mathfrak{c}) \}\]</div>
<p>Note, since sets do not preserve order, this would be equivalent to,</p>
<div class="math notranslate nohighlight">
\[\{ (3, \mathfrak{a}), (2, \mathfrak{b}), (1, \mathfrak{c}) \}\]</div>
<p>To simplify notation, it is sometimes beneficial to represent this set as a sequence that <em>does</em> preserve order as,</p>
<div class="math notranslate nohighlight">
\[S_1 = (\mathfrak{a}, \mathfrak{b}, \mathfrak{c})\]</div>
<p>However, before adopting this notation formally, a problem exists. It is the intention of this analysis to treat Empty Characters as vacuous, i.e. Characters without semantic content. However, this does not mean the Empty Character will not be treated as a legitimate entity within the confines of the formal system. Instead, the goal is to construct a formal system that excludes the Empty Character from the domain of semantics, but not the domain of syntax.</p>
<p>Due to the nature of the Empty Character and its ability to be concatenated ad infinitum, and the desire to construct a theory of Words and Language that emerges from the transcendental domain of Strings, the construction of the Character-level set representation of a String requires a special algorithm to filter out any Empty Characters while preserving the relative order of the non-Empty Characters concatenated into the String.</p>
<p>Before presenting the <em>Emptying Algorithm</em> that will allow the construction of the Character-level representation of an arbitrary String, motivation for the particular form of the Emptying Algorithm is given by way of analogy to assembly language in computer science.</p>
<p>At the most primitive level, iteration in assembly or machine language is essentially achieved through a combination of two components,</p>
<blockquote>
<div><ol class="arabic">
<li><p>Memory Addresses: Data, including Strings (which are just sequences of Characters), is stored in memory at specific addresses.</p></li>
<li><p>Registers: The CPU has special memory locations called registers. Registers are used to hold,</p>
<blockquote>
<div><ul class="simple">
<li><p>Data: Values being currently processed.</p></li>
<li><p>Pointers: Memory addresses of data being accessed.</p></li>
<li><p>Counters: Values used to keep track of the iteration‚Äôs progress.</p></li>
<li><p>Instructions: The CPU executes a sequence of instructions.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p>The Instruction set consists of operations for,</p>
<blockquote>
<div><ul class="simple">
<li><p>Load data: Move data from memory to registers.</p></li>
<li><p>Store data: Move data from registers to memory.</p></li>
<li><p>Arithmetic operations: Perform calculations (like adding 1).</p></li>
<li><p>Conditional jumps: Change the flow of execution based on certain conditions (e.g., checking if a counter has reached a certain value).</p></li>
</ul>
</div></blockquote>
<p>At the assembly level, a typical algorithm for iterating through a String is given below (the semi-colon ‚Äú;‚Äù denotes a code comment),</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="n">Assume</span><span class="p">:</span>
<span class="p">;</span>   <span class="o">-</span> <span class="n">String</span> <span class="s2">&quot;abc&quot;</span> <span class="ow">is</span> <span class="n">stored</span> <span class="n">at</span> <span class="n">memory</span> <span class="n">address</span> <span class="n">STRING_START</span>
<span class="p">;</span>   <span class="o">-</span> <span class="n">STRING_START</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">0</span>  <span class="p">(</span><span class="mi">0</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">null</span> <span class="n">terminator</span> <span class="n">indicating</span> <span class="n">the</span> <span class="n">end</span><span class="p">)</span>
<span class="p">;</span>   <span class="o">-</span> <span class="n">Register</span> <span class="n">R1</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span> <span class="k">as</span> <span class="n">a</span> <span class="n">pointer</span> <span class="p">(</span><span class="n">initially</span> <span class="n">holds</span> <span class="n">STRING_START</span><span class="p">)</span>
<span class="p">;</span>   <span class="o">-</span> <span class="n">Register</span> <span class="n">R2</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span> <span class="k">as</span> <span class="n">a</span> <span class="n">counter</span> <span class="p">(</span><span class="n">initially</span> <span class="n">holds</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">LOOP_START</span><span class="p">:</span>
    <span class="n">LOAD</span> <span class="n">R3</span><span class="p">,</span> <span class="p">(</span><span class="n">R1</span><span class="p">)</span>     <span class="p">;</span> <span class="n">Load</span> <span class="n">the</span> <span class="n">character</span> <span class="n">at</span> <span class="n">the</span> <span class="n">address</span> <span class="ow">in</span> <span class="n">R1</span> <span class="n">into</span> <span class="n">R3</span>
    <span class="n">CMP</span> <span class="n">R3</span><span class="p">,</span> <span class="mi">0</span>        <span class="p">;</span> <span class="n">Compare</span> <span class="n">R3</span> <span class="k">with</span> <span class="n">the</span> <span class="n">null</span> <span class="n">terminator</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">JE</span> <span class="n">LOOP_END</span>      <span class="p">;</span> <span class="n">If</span> <span class="n">R3</span> <span class="ow">is</span> <span class="mi">0</span> <span class="p">(</span><span class="n">equal</span><span class="p">),</span> <span class="n">jump</span> <span class="n">to</span> <span class="n">LOOP_END</span>
    <span class="n">ADD</span> <span class="n">R1</span><span class="p">,</span> <span class="mi">1</span>        <span class="p">;</span> <span class="n">Increment</span> <span class="n">R1</span> <span class="p">(</span><span class="n">move</span> <span class="n">the</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">character</span><span class="s1">&#39;s address)</span>
    <span class="n">ADD</span> <span class="n">R2</span><span class="p">,</span> <span class="mi">1</span>        <span class="p">;</span> <span class="n">Increment</span> <span class="n">the</span> <span class="n">counter</span> <span class="n">R2</span>
    <span class="n">JMP</span> <span class="n">LOOP_START</span>   <span class="p">;</span> <span class="n">Jump</span> <span class="n">back</span> <span class="n">to</span> <span class="n">LOOP_START</span>
<span class="n">LOOP_END</span><span class="p">:</span>
</pre></div>
</div>
<p>A step-by-step breakdown of this algorithm is instructive for understanding how iterationg through String is implemented at the most basic level in the theory of computation. Each command in this assembly-like language is broken down as follows,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>R1 (pointer) is set to STRING_START.</p></li>
<li><p>R2 (counter) is set to 0.</p></li>
<li><p>LOOP_START: This is a label marking the beginning of the loop.</p></li>
<li><p>LOAD R3, (R1): The Character at the memory address stored in R1 is loaded into register R3.</p></li>
<li><p>CMP R3, 0: The character in R3 is compared to the null terminator (0).</p></li>
<li><p>JE LOOP_END: If the comparison is equal (meaning the end of the string has been reached), the program jumps to the LOOP_END label.</p></li>
<li><p>ADD R1, 1: This is the crucial step where the pointer is incremented. 1 is added to R1 because each Character occupies one memory location (in this simplified example). This moves the pointer to the next Character‚Äôs address.</p></li>
<li><p>ADD R2, 1: The counter is incremented.</p></li>
<li><p>JMP LOOP_START: The program jumps back to the beginning of the loop.</p></li>
</ol>
</div></blockquote>
<p>The key idea is this algorithm is <em>‚Äúunaware‚Äù</em> of how <em>long</em> the String is that is stored in the <em>R1</em> register. The algorithm naively iterates over the data and then checks whether or not the data has been processed with the command <em>CMP R3, 0</em>, i.e. the algorithm checks whether or not the next Character in the String <em>exists</em>.</p>
<p>By treating Strings as Characters stored sequentially in a data register, this algorithm is able to construct a representation of the String on a higher level, allowing for the definition of derivative concepts, like String Length.</p>
<p>This insight leads directly to the definition of the Character-level set representation of a String and its construction via the Emptying Algorithm.</p>
<p id="definition-1-1-2"><strong>Definition 1.1.2: Character-level Set Representations</strong></p>
<p>Let <em>t</em> be a String with Characters <em>ùîû</em><sub>i</sub>. The Character-level set representation of <em>t</em>, denoted by bold uppercase letters <strong>T</strong>, is defined as the ordered set of Characters obtained by removing each Empty Character, <em>Œµ</em>. Formally, <strong>T</strong> is constructed using the <em>Emptying Algorithm</em></p>
<p id="algorithm-1"><strong>Algorithm 1: The Emptying Algorithm</strong></p>
<p>The Emptying Algorithm takes a string <em>t</em> as input, which can be thought of as a sequence of Characters <em>ùîû</em><sub>1</sub>, <em>ùîû</em><sub>2</sub>, <em>ùîû</em><sub>3</sub>, ‚Ä¶ , where some characters might be <em>Œµ</em>. It then initializes a set to hold <strong>T</strong> and an index for the Characters it will add to <strong>T</strong>. The algorithm iterates the index and constructs the Character-level representation by ignoring <em>Œµ</em>. The Emptying Algorithm is formally defined below.</p>
<aside class="topic">
<p class="topic-title">Algorithm Empty(t: String)</p>
<p># Input: A string t</p>
<p># Output: An ordered set T representing the character-level set representation of t</p>
<p># Initialization</p>
<p>## empty set to hold Character-level representation</p>
<p>T ‚Üê ‚àÖ</p>
<p>## index for non-Empty Characters in T</p>
<p>j ‚Üê 1</p>
<p>## index for iterating through original String t</p>
<p>i ‚Üê 1</p>
<p># Iteration</p>
<ol class="arabic">
<li><p>While ùîû:sub:<cite>i</cite> exists:</p>
<blockquote>
<div><ol class="loweralpha">
<li><p>If ùîû:sub:<cite>i</cite> ‚â† Œµ:</p>
<blockquote>
<div><ol class="lowerroman simple">
<li><p>T ‚Üê { (j, ùîû:sub:<cite>i</cite>) } ‚à™ T</p></li>
<li><p>j ‚Üê j + 1</p></li>
</ol>
</div></blockquote>
</li>
<li><p>i ‚Üê i + 1</p></li>
</ol>
</div></blockquote>
</li>
</ol>
<ol class="arabic simple">
<li><p>Return T</p></li>
</ol>
</aside>
<p>‚àé</p>
<figure class="align-default" id="id9">
<div class="graphviz"><img src="../_images/graphviz-84fc378a9fb39c30ecd6498cf7ec029352df24ae.png" alt="Emptying Algorithm Diagram" class="graphviz" /></div>
<figcaption>
<p><span class="caption-text">A diagram of the Emptying Algorithm</span><a class="headerlink" href="#id9" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Step 1 in the Emptying Algorithm is essentially equivalent to a <em>try-catch</em> block in modern programming languages. Step 1 is materially different than comparing a Character in a String to the Empty Character. Step 1 relies on the idea that attempting to select a Character outside of the String is an undefined operation and will thus result in an error (i.e. a stack overflow). As the Characters in a String are iterated through, as long as the String is not infinite, the iteration will eventually reach the last Character, and once it tries to select the next Character, it will throw an error.</p>
<p>This point is important because the Emptying Algorithm must remain <em>‚Äúunaware‚Äù</em> of String Length. The essence of the Emptying Algorithm is that it implicitly defines the length of the String as its number of non-Empty Characters, without explicitly stating that is what <em>String Length</em> is or how it is calculated. This is crucial to the formalization of Strings as ordered sequences of Characters, because it allows String Length to be defined without any circularity. In other words, this formalization avoids the vicous circle of defining the Character-level representation in terms of String Length and then defining String Length as the cardinality of the Character-level representation.</p>
<p>The following example illustrates a simple application of the Emptying Algorithm.</p>
<p><strong>Example</strong></p>
<p>Let <em>t = (‚Äúab‚Äù)(Œµ)(‚Äúc‚Äù)</em>.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>i = 1, ùîû:sub:<cite>1</cite> = ‚Äúa‚Äù. Add (1, ‚Äúa‚Äù) to T. j increases to 2. i increases to 2.</p></li>
<li><p>i = 2, ùîû:sub:<cite>2</cite> = ‚Äúb‚Äù. Add (2, ‚Äúb‚Äù) to T. j increases to 3. i increases to 3.</p></li>
<li><p>i = 3, ùîû:sub:<cite>3</cite> = Œµ. Skip Empty Character. i increases to 4.</p></li>
<li><p>i = 4, ùîû:sub:<cite>4</cite> = ‚Äúc‚Äù. Add (3, ‚Äúc‚Äù) to T. j increases to 4. i increases to 5.</p></li>
<li><p>i = 5, ùîû:sub:<cite>5</cite> does not exist. Algorithm halts.</p></li>
</ol>
</div></blockquote>
<p>The result returned by the Emptying Algorithm would then be,</p>
<div class="math notranslate nohighlight">
\[T = \{ (1, \text{&quot;a&quot;}), (2, \text{&quot;b&quot;}), (3, \text{&quot;c&quot;}) \}\]</div>
<p>Note the Emptying Algorithm results in consecutive indices while also removing the Empty Character. ‚àé</p>
<p>This method of abstraction and notation will be employed extensively in the subsequent proofs. It will be made more convenient with Character Index notation in the next section, after the preliminary notion of <em>String Length</em> is defined. However, in order to define String Length, a method of referring to a String as a set of ordered non-Empty Characters is required. The construction afforded by the Emptying Algorithm operating on any input String <em>t</em> will serve that purpose.</p>
<p>As a brief aside, it may seem the formal system would be better developed by excluding the Empty Character altogether from its Alphabet. The Empty Character‚Äôs presence in the Alphabet complicates matter extensively, requiring intricate and subtle definitions.</p>
<p>The reasons for this are two-fold. First: the Empty Character <em>Œµ</em> plays a part in the <em>Pivot</em> of a Palindrome, the point around which a certain class of Palindrome reflect. Second: Strings consisting of only the Empty Character are not a mere novelty of abstraction; They play a crucial role in computer science and database management. Any rigorous formal system that excludes the notion of an Empty Character will fail to describe the exact domain from which Language arises, and thus it may fail to account for pre-Language syntactical conditions that necessarily affect the formation of Language.</p>
<p>This approach is not without its challenges. As <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a> below will make clear, if <em>Œµ</em> is considered part of the Alphabet, the typical notion of a String‚Äôs Length is undefined, as <em>Œµ</em> can be concatenated an infinite number of times to a String without altering its content. To explicate the notion of <em>length</em>, consider the constraints that must be placed on this concept in the palindromic system,</p>
<blockquote>
<div><ul class="simple">
<li><p>The length of the string ‚Äúabc‚Äù is 3, as it contains three non-Empty Characters.</p></li>
<li><p>The length of the string ‚ÄúaŒµbŒµc‚Äù is still 3, as the Empty Characters (<em>Œµ</em>) are not counted.</p></li>
</ul>
</div></blockquote>
<p>This example motivates the following definition.</p>
<p id="definition-1-1-3"><strong>Definition 1.1.3: String Length</strong></p>
<p>Let <em>t</em> be a String. Let <strong>T</strong> be the Character-level set representation of <em>t</em> constructed through the Emptying Algorithm in <a class="reference internal" href="#definition-1-1-2"><span class="std std-ref">Definition 1.1.2</span></a>. The String Length of <em>t</em>, denoted <em>l(t)</em>, is the number which satisfies the following formula,</p>
<div class="math notranslate nohighlight">
\[l(t) = \lvert T \rvert\]</div>
<p>‚àé</p>
<p><strong>Example</strong></p>
<p>Consider the String <em>t = (‚Äúaa‚Äù)(Œµ)(‚Äúb‚Äù)(Œµ)(‚Äúbcc‚Äù)</em></p>
<p>By <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a>,</p>
<div class="math notranslate nohighlight">
\[T = \{ (1, \text{&quot;a&quot;}), (2, \text{&quot;a&quot;}), (3, \text{&quot;b&quot;}), (4, \text{&quot;b&quot;}), (5, \text{&quot;c&quot;}), (6, \text{&quot;c&quot;}) \}\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[\lvert T \rvert = 6\]</div>
<p>‚àé</p>
<p>This formalization of String Length, with the Emptying Algorithm, while perhaps prosaic, maps to the intuitive notion of a String‚Äôs length, i.e. the number of non-Empty Characters, while still allowing for a calculus of concatenation that involves Empty Characters. For reasons that will become clear in Section II, <em>l(s)</em> will be called the <em>String Length</em> of a String s.</p>
<p>To confirm <a class="reference internal" href="#definition-1-1-2"><span class="std std-ref">Definition 1.1.2</span></a> and <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a> correspond to reality, a theorem confirming its expected behavior is now derived. <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a> ensures the String Length of concatenated Strings is equal to the sum of their individual String Lengths, as demonstrated by <a class="reference internal" href="#theorem-1-1-1"><span class="std std-ref">Theorem 1.1.1</span></a>.</p>
<p id="theorem-1-1-1"><strong>Theorem 1.1.1</strong> <span class="math notranslate nohighlight">\(\forall u, t \in S : l(ut) = l(u) + l(t)\)</span></p>
<p>Let <em>u</em> and <em>t</em> be arbitrary strings in <strong>S</strong>. Let <strong>U</strong> and <strong>T</strong> be the character-level representations of <em>u</em> and <em>t</em>, respectively,</p>
<div class="math notranslate nohighlight">
\[1. \quad U = ( \mathfrak{a}_1, \mathfrak{a}_2, ..., \mathfrak{a}_{l(u)} )\]</div>
<div class="math notranslate nohighlight">
\[2. \quad T = ( \mathfrak{b}_1, \mathfrak{b}_2, ..., \mathfrak{b}_{l(t)} )\]</div>
<p>Let <em>ut</em> be the concatenation of <em>u</em> and <em>t</em>. By <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a>, the Character-level representation of <em>ut</em> is,</p>
<div class="math notranslate nohighlight">
\[3. \quad UT = ( \mathfrak{a}_1, \mathfrak{a}_2, ..., \mathfrak{a}_{l(u)}, \mathfrak{b}_1, \mathfrak{b}_2, ..., \mathfrak{b}_{l(t)})\]</div>
<p>By <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a>, the String Length of a String is the number of indexed non-Empty Characters it contains. Thus, <span class="math notranslate nohighlight">\(l(u)\)</span> is the number of non-Empty Characters in <em>u</em>, <span class="math notranslate nohighlight">\(l(t)\)</span> is the number of non-Empty Characters in <em>t</em>, and <span class="math notranslate nohighlight">\(l(ut)\)</span> is the number of non-Empty Characters in <em>ut</em>.</p>
<p>Since concatenation simply joins Characters without adding or removing Characters, with the possible exception of Empty Characters through the Basis Clause of <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a>, the non-Empty Characters in <em>ut</em> are precisely the non-Empty Characters from <em>u</em> followed by the non-Empty Characters from <em>t</em>.</p>
<p>Therefore, the total number of non-Empty Characters in <em>ut</em> is the sum of the number of non-Empty characters in <em>u</em> and the number of non-Empty Characters in <em>t</em>,</p>
<div class="math notranslate nohighlight">
\[4. \quad l(ut) = l(u) + l(t)\]</div>
<p>Since <em>u</em> and <em>t</em> were arbitrary strings, this can be generalized over the set of all Strings,</p>
<div class="math notranslate nohighlight">
\[5. \quad \forall u, t \in S : l(ut) = l(u) + l(t)\]</div>
<p>‚àé</p>
<p>With the concept of String Length now defined, it is also a simple matter to define String Equality in terms of Character Equality using the <a class="reference internal" href="#axiom-c0"><span class="std std-ref">Equality Axiom C.0</span></a>.</p>
<p id="definition-1-1-4"><strong>Definition 1.1.4: String Equality</strong></p>
<p>Let <em>t</em> be a String. Let <strong>T</strong> be the Character-level set representation of <em>t</em> constructed through <a class="reference internal" href="#definition-1-1-2"><span class="std std-ref">Definition 1.1.2</span></a>,</p>
<div class="math notranslate nohighlight">
\[T = \{ (i, \mathfrak{a}_i) \mid 1 \leq i \leq l(t) \}\]</div>
<p>Let <em>u</em> be a String. Let <strong>U</strong> be the Character-level set representation of <em>u</em> constructed through <a class="reference internal" href="#definition-1-1-2"><span class="std std-ref">Definition 1.1.2</span></a>,</p>
<div class="math notranslate nohighlight">
\[U = \{ (i, \mathfrak{b}_j) \mid 1 \leq j \leq l(u) \}\]</div>
<p>The string <em>t</em> is said to be <em>equal</em> to String <em>u</em> if the Strings have equal length and the Characters at each corresponding index are equal. Formally, <em>t = u</em> if and only if,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(l(t) = l(u)\)</span> (The String Lengths of t and u are equal)</p></li>
<li><p><span class="math notranslate nohighlight">\(\forall i \in N_{l(t)}: \mathfrak{a}_{i} = \mathfrak{b}_{i}\)</span> (The Characters at each corresponding index are equal)</p></li>
</ol>
</div></blockquote>
<p>‚àé</p>
<p>Finally, String Length provides the means for a quality-of-life enhancement to the formal system in the form of Character Index notation.</p>
<p id="definition-1-1-5"><strong>Definition 1.1.5: Character Index Notation</strong></p>
<p>Let <em>t</em> be a string with Character-level representation <strong>T</strong>,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[T = (\mathfrak{a}_1, \mathfrak{a}_2, ..., \mathfrak{a}_{l(t)}).\]</div>
</div></blockquote>
<p>Then for any <em>i</em> such that <span class="math notranslate nohighlight">\(1 \leq i \leq l(t)\)</span>, <span class="math notranslate nohighlight">\(t[i]\)</span> is defined as <em>ùîû</em><sub>i</sub>, where <span class="math notranslate nohighlight">\((i, \mathfrak{a}_i) \in T\)</span>. ‚àé</p>
<p>Character Index notation will simplify many of the subsequent proofs, so it is worth taking a moment to become familiar with its usage. Indexing starts at 1, consistent with the definition of <strong>N</strong><sub>n</sub> made in the preamble. So, <em>t[1]</em> is the first character of <em>t</em>, <em>t[2]</em> is the second, and so on.</p>
<p>In terms of the Character-level set representation, <em>t[i]</em> refers to the Character at position <em>i</em> in the set <strong>T</strong>. In other words, the notation <em>t[i]</em> implicitly assumes the String <em>t</em> has already been stripped of its Empty Characters through the Emptying Algorithm in <a class="reference internal" href="#definition-1-1-2"><span class="std std-ref">Definition 1.1.2</span></a>. This notation can effectively replace the use of lowercase Fraktur letters with subscripts (e.g., <em>ùîû</em><sub>i</sub>) when referring to specific Characters within Strings.</p>
<p><strong>Example</strong></p>
<p>If <em>s = ‚Äúabc‚Äù</em>, then <em>s[1] = ‚Äúa‚Äù</em>, <em>s[2] = ‚Äúb‚Äù</em>, and <em>s[3] = ‚Äúc‚Äù</em>. ‚àé</p>
<p>With the notion of String Length established for each element in the domain and some of its basic properties established, the size of the domain itself, <strong>S</strong>, will now be elaborated in greater detail.</p>
<p>It is assumed <strong>S</strong> is at least uncountably infinite. A rigorous proof of this fact would carry the current work too far into the realm of real analysis, but as motivation for this assumption, an informal proof is presented below based on Cantor‚Äôs famous diagonalization argument.</p>
<p id="theorem-1-1-2"><strong>Theorem 1.1.2</strong> <span class="math notranslate nohighlight">\(\lvert S \rvert \geq \aleph_{1}\)</span></p>
<p>Assume, for the sake of contradiction, that the set of all Strings <strong>S</strong> is countable. This means the Strings can be listed in some order,</p>
<div class="math notranslate nohighlight">
\[1. \quad s_1, s_2, s_3, ...\]</div>
<p>Now, construct a new String <em>t</em> as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The first character of <em>t</em> is different from the first character of <em>s</em><sub>1</sub>.</p></li>
<li><p>The second character of <em>t</em> is different from the second character of <em>s</em><sub>2</sub>.</p></li>
<li><p>etc.</p></li>
</ol>
</div></blockquote>
<p>This string <em>t</em> will be different from every string in <strong>S</strong> contradicting the assumption that it was possible to list all strings. Therefore, <strong>S</strong> must be uncountable. ‚àé</p>
</section>
<section id="containment">
<span id="id4"></span><h3>Containment<a class="headerlink" href="#containment" title="Link to this heading">#</a></h3>
<p>Similar to the explication of <em>length</em>, the notion of a String <em>containing</em> another String must be made precise using the definitions introduced so far. It‚Äôs important to note that in the current system the relation of <em>containment</em> is materially different from the standard subset relation between sets. For example, the set of characters in <em>‚Äúrat‚Äù</em> is a subset of the set of characters in <em>‚Äútart‚Äù</em>, but <em>‚Äúrat‚Äù</em> is not contained in <em>‚Äútart‚Äù</em> because the order of the characters is different.</p>
<p>Consider the Strings <em>‚Äúrat‚Äù</em> and <em>‚Äústrata‚Äù</em>. The string <em>‚Äúrat‚Äù</em> <em>is contained</em> in the String strata‚Äù, because the order of the String <em>‚Äúrat‚Äù</em> is preserved in <em>‚Äústrata‚Äù</em>. An intuitive way of capturing this relationship is to map the indices of the Characters in <em>‚Äúrat‚Äù</em> to the indices of the Characters in <em>‚Äústrata‚Äù</em> which correspond to the indices in <em>‚Äúrat‚Äù</em>. A cursory (but incorrect) definition of <em>containment</em> can then be attempted, using this insight as a guide.</p>
<p><strong>Containment (Incorrect Version)</strong> <span class="math notranslate nohighlight">\(t \subset_s u\)</span></p>
<p>Let <em>t</em> and <em>u</em> be Strings. <em>t</em> is said to be <em>contained in u</em>, denoted by,</p>
<div class="math notranslate nohighlight">
\[t \subset_s u\]</div>
<p>If and only if there exists a strictly increasing function <span class="math notranslate nohighlight">\(f: N_{l(t)} \to N_{l(u)}\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[\forall i \in N_{l(t)}: t[i] = u[f(i)]\]</div>
<p>‚àé</p>
<p>This definition essentially states that <em>t</em> is contained in <em>u</em> if and only if there‚Äôs a way to map the Characters of <em>t</em> onto a subsequence of the Characters in <em>u</em> while preserving their order. The function <em>f</em> ensures that the Characters in <em>t</em> appear in the same order within <em>u</em>. While this definition is incorrect, the reason why this version of <em>containment</em> fails is instructive in developing a better understanding of the subtlety involved in attempting its definition.</p>
<p>First, consider an example where this definition correlates with the intuitive notion of <em>containment</em>. Let <em>t = ‚Äúrat‚Äù</em> and <em>u = ‚Äústrata‚Äù</em>. Then, these Strings can be represented in set notation as,</p>
<div class="math notranslate nohighlight">
\[T = \{ (1, \text{&quot;r&quot;}), (2, \text{&quot;a&quot;}), (3, \text{&quot;t&quot;}) \}\]</div>
<div class="math notranslate nohighlight">
\[U = \{ (1, \text{&quot;s&quot;}), (2, \text{&quot;t&quot;}), (3, \text{&quot;r&quot;}), (4, \text{&quot;a&quot;}), (5, \text{&quot;t&quot;}), (6, \text{&quot;a&quot;}) \}.\]</div>
<p>The function <em>f</em> defined as <span class="math notranslate nohighlight">\(f(1) = 3\)</span>, <span class="math notranslate nohighlight">\(f(2) = 4\)</span>, and <span class="math notranslate nohighlight">\(f(3) = 5`\)</span> satisfies the condition in the proposed definition, as it maps the characters of <em>‚Äúrat‚Äù</em> onto the subsequence <em>‚Äúrat‚Äù</em> within <em>‚Äústrata‚Äù</em> while preserving their order. In addition, <em>f</em> is a strictly increasing function. Therefore,</p>
<div class="math notranslate nohighlight">
\[\text{&quot;rat&quot;} \subset_{s} \text{&quot;strata&quot;}\]</div>
<p>Next, consider a counter-example. Let <em>t = ‚Äúbow‚Äù</em> and <em>u = ‚Äúborrow‚Äù</em>. Then their corresponding set representations are given by,</p>
<div class="math notranslate nohighlight">
\[T = \{ (1, \text{&quot;b&quot;}), (2, \text{&quot;o&quot;}), (3, \text{&quot;w&quot;}) \}\]</div>
<div class="math notranslate nohighlight">
\[U = \{ (1, \text{&quot;b&quot;}), (2, \text{&quot;o&quot;}), (3, \text{&quot;r&quot;}), (4, \text{&quot;r&quot;}), (5, \text{&quot;o&quot;}), (6, \text{&quot;w&quot;}) \}\]</div>
<p>The function defined through <span class="math notranslate nohighlight">\(f(1) = 1\)</span>, <span class="math notranslate nohighlight">\(f(2) = 5\)</span> and  <span class="math notranslate nohighlight">\(f(3) = 6\)</span> satisfies the conditions of the proposed definition. However, intuitively, <em>‚Äúbow‚Äù</em> is <em>not contained</em> in the word <em>‚Äúborrow‚Äù</em>. The reason the proposed definition has failed is now clear: the function <em>f</em> that is mapping <em>‚Äúbow‚Äù</em> to <em>‚Äúborrow‚Äù</em> skips over the Character indices 2, 3 and 4 in <em>‚Äúborrow‚Äù</em>. In other words, in addition to being strictly increasing, the function <em>f</em> which maps the smaller String onto the larger String must also be <em>consecutive</em>. This insight can be incorporated into the definition of <em>containment</em> by first defining the notion of <em>consecutive</em>,</p>
<p id="definition-1-1-6"><strong>Definition 1.1.6: Consecutive Functions</strong></p>
<p>A function <em>f</em> is consecutive over <strong>N</strong><sub>s</sub> if it satisfies the formula,</p>
<div class="math notranslate nohighlight">
\[\forall i, j \in N_s: (i &lt; j) \to f(j) = f(i) + (j - i)`\]</div>
<p>‚àé</p>
<p>This additional constraint on <em>f</em> ensures that the indices of the larger String in the containment relation are mapped in a sequential, unbroken order to the indices of the smaller String. This definition of <em>Consecutive Functions</em> can be immediately utilized to refine the notion of <em>containment</em>.</p>
<p id="definition-1-1-7"><strong>Definition 1.1.7: Containment</strong> <span class="math notranslate nohighlight">\(t \subset_{s} u\)</span></p>
<p>Let <em>t</em> and <em>u</em> be Strings. <em>t</em> is said to be <em>contained in u</em>, denoted by,</p>
<div class="math notranslate nohighlight">
\[t \subset_{s} u\]</div>
<p>If and only if there exists a strictly <em>increasing and consecutive</em> function <span class="math notranslate nohighlight">\(f: N_{l(t)} \to N_{l(u)}\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[\forall i \in N_{l(t)}: t[i] = u[f(i)]\]</div>
<p>‚àé</p>
<p>The notion of containment will be central to developing the logic of palindromic structures in the subsequent sections. The next theorem establishes a fundamental property regarding containment.</p>
<p id="theorem-1-1-3"><strong>Theorem 1.1.3</strong> <span class="math notranslate nohighlight">\(\forall s \in S: \varepsilon \subset_s s\)</span></p>
<p>Let <em>s</em> be an arbitrary string in <strong>S</strong>. By <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a>, <span class="math notranslate nohighlight">\(l(\varepsilon) = 0\)</span>. Thus,</p>
<div class="math notranslate nohighlight">
\[1. \quad N_{l(\varepsilon)} = \emptyset\]</div>
<p>The empty function <span class="math notranslate nohighlight">\(f: \emptyset \to N_{l(s)}\)</span> vacuously satisfies the condition for containment (<a class="reference internal" href="#definition-1-1-7"><span class="std std-ref">Definition 1.1.7</span></a>), as there are no elements in the domain to violate the condition. Therefore,</p>
<div class="math notranslate nohighlight">
\[2. \quad \varepsilon \subset_s s\]</div>
<p>Since <em>s</em> was arbitrary, this can be generalized over the set of all Strings,</p>
<div class="math notranslate nohighlight">
\[3. \quad \forall s \in S: \varepsilon \subset_s s\]</div>
<p>‚àé</p>
</section>
</section>
<section id="section-i-ii-words">
<span id="section-i-ii"></span><h2>Section I.II: Words<a class="headerlink" href="#section-i-ii-words" title="Link to this heading">#</a></h2>
<p>While the notion of Characters maps almost exactly to the intuitive notion of letters in everyday use, the notion of a <em>Word</em> requires explication.</p>
<p>If Characters are mapped to letters in the Alphabet of a Language <strong>L</strong>, the set of all Strings would have as a subset the Language that is constructed through the Alphabet. The goal of this section is to define the syntactical properties of Words in <strong>L</strong> that differentiates them from Strings in <strong>S</strong> based solely on their internal cohesion as a linguistic unit. The intent of this analysis is to treat Words as interpretted constructs embedded in a syntactical structure that is independent of their specific interpretations. In other words, this analysis will proceed without assuming anything about the interpretation of the Words in the Language beyond the fact that they <em>are</em> Words of the Language. The goal is to leave the semantic interpretation of Words in a Language as ambiguous as possible. This ambiguity, it is hoped, will leave the results of the analysis applicable to palindromic structures in a variety of languages, and perhaps make the formal system applicable to areas outside the realm of Palindromes.</p>
<p id="definition-1-2-1"><strong>Definition 1.2.1: Language</strong></p>
<p>A Language <strong>L</strong> is a set of Strings constructed through concatenation on an Alphabet <strong>Œ£</strong> that are assigned semantic content. ‚àé</p>
<p id="definition-1-2-2"><strong>Definition 1.2.2: Word</strong></p>
<p>A Word is an element of a Language <strong>L</strong>. ‚àé</p>
<p>The following symbolic notation is introduced for these terms,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Words (<em>a</em>, <em>b</em>, <em>c</em>, etc.): Lowercase English letters represent Words. Subscripts will occassionally be used to denote Words, (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ‚Ä¶ )</p></li>
<li><p>Language (<strong>L</strong>): The uppercase English letter <em>L</em> in boldface represents a Language.</p></li>
</ol>
</div></blockquote>
<p>In the case of English, Words would correspond to words such as ‚Äúdog‚Äù, ‚Äúcat‚Äù, etc. A Language would correspond to a set of words such as <span class="math notranslate nohighlight">\(\{ \text{&quot;dog&quot;}, \text{&quot;cat&quot;}, \text{&quot;hamster&quot;}, ... \}\)</span> or <span class="math notranslate nohighlight">\(\{ \text{&quot;tree&quot;}, \text{&quot;flower&quot;}, \text{&quot;grass&quot;}, .... \}\)</span>. The number of Words in a Language is denoted <span class="math notranslate nohighlight">\(\lvert L \rvert\)</span>.</p>
<p>Again, at the risk of unwarranted repetition, Language is assumed to be a <em>fixed set</em> known a priori to the construction of the current formal system. It not the goal of the formal system to describe the semantic conditions for a Word‚Äôs eligibility in Language or how a Language is constructed from elementary Characters and Strings into a class of Words through systems like grammar or pragmatics, but rather, given a Language of Words, the formal system seeks to elaborate the syntactical conditions that are imposed on Language by its nature as a set of Strings with ordered Characters.</p>
<p>Note, <a class="reference internal" href="#definition-1-2-1"><span class="std std-ref">Definition 1.2.1</span></a> and <a class="reference internal" href="#definition-1-2-2"><span class="std std-ref">Definition 1.2.2</span></a> relies on the idea that Words are Strings and their meaning is conveyed through the ordered sequence of its concatenated Characters. This necessarily precludes from the formal system any languages which do <em>not</em> use the ordering of Characters as the primary medium for representing Words. While edge cases like sign language exist, nevertheless, the sole constitutive feature of any natural is the <em>ordering</em> of some type of Character. In the case of sign language, a Character in the formal system might be identified with <em>‚Äúa configuration of fingers‚Äù</em> and a String might be identified with <em>‚Äúconfigurations over time‚Äù</em>.</p>
<p>It will sometimes be necessary to refer to indeterminate Words, so notation is introduced for Word Variables,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Word Variables (<em>Œ±</em>, <em>Œ≤</em>, <em>Œ≥</em>): The Lowercase Greek letters Alpha, Beta and Gamma will represent variable Words, i.e. indeterminate Words. Subscripts will occassionally be used with Alpha to denote Word Variables, (<em>Œ±</em><sub>1</sub>, <em>Œ±</em><sub>2</sub>, ‚Ä¶ ).</p></li>
</ol>
</div></blockquote>
<p>The range of a Word Variable is understood to be the Language <strong>L</strong> from the Words are being drawn.</p>
<p>With these definitions, the hierarchy of relationships that exist between a Word <em>Œ±</em>, its Language <strong>L</strong> and the set of all Strings <strong>S</strong> is given by,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\alpha \in L\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha \in S\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(L \subset S\)</span></p></li>
</ol>
</div></blockquote>
<p>To clarify the relationship between Strings, Words and Language in plain language,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>All Words belong to a Language.</p></li>
<li><p>All Words belong to the set of all Strings</p></li>
<li><p>Language is a subset of the set of all Strings.</p></li>
<li><p>Not all Strings are Words.</p></li>
</ol>
</div></blockquote>
<p>As mentioned several times, all objects in this formal system are defined on the domain of Strings through either the set relation of ‚Äúbelonging‚Äù or the set relation of ‚Äúsubset‚Äù. Words and Characters are different types of Strings, while a Language is a subset of Strings. Because Words are Strings, defining their equality is a simple matter of referring back to the definition of String Equality.</p>
<p id="definition-1-2-3"><strong>Definition 1.2.3: Word Equality</strong></p>
<p>Let <em>a</em> and <em>b</em> be words in <strong>L</strong>. Then <em>a = b</em> if and only if <em>a</em> and <em>b</em> are equal as Strings (according to <a class="reference internal" href="#definition-1-1-4"><span class="std std-ref">Definition 1.1.4</span></a>). ‚àé</p>
<p>The next axiom represents the minimal <em>necessary</em> assumptions that are placed on any String to be considered an element of a Language <strong>L</strong>, i.e. a Word. The axiom listed in this section is not <em>sufficient</em>; in other words, it is possible for a String to satisfy this axiom without being an element of a Language, but any Word that belongs to a Language must satisfy the axiom.</p>
<p id="axiom-w1"><strong>Axiom W.1: The Discovery Axiom</strong></p>
<div class="math notranslate nohighlight">
\[\forall \alpha \in L: [ (l(\alpha) \neq 0) \land (\forall i \in N_{l(\alpha)}: \alpha[i] \neq \sigma) ]\]</div>
<p>‚àé</p>
<p>There are two conjuncts in the <a class="reference internal" href="#axiom-w1"><span class="std std-ref">Discovery Axiom W.1</span></a> and each of them captures a noteworthy assumption that is being made about Words in a Language. The first conjunct, (<span class="math notranslate nohighlight">\(l(\alpha) \neq 0\)</span>), will be used to prove some fundamental properties of Words in the next section. This condition that a Word‚Äôs String Length cannot be equal to zero serves a dual purpose. First, by <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a>, it ensures the Empty Character cannot be a Character in a Word (this fact will be more rigorously proven in <a class="reference internal" href="#theorem-1-2-4"><span class="std std-ref">Theorem 1.2.4</span></a> below), preventing vacuous semantic content.</p>
<p>Second, in order for two Words to be distinguished as the same Word, there must be dimensions of comparision over which to assert the equality. One must have some criteria for saying <em>this</em> linguistic entity is equal to that <em>that</em> linguistic entity. String Length serves as one of the two dimensions for a Word necessary for a word to be ‚Äúembodied‚Äù in a medium (the other being the inherent ordinality of Characters in a Word). In other words, the concept of String Length is foundational to the discovery of Words from the set of all Strings <strong>S</strong>. One must be able to discard those Strings possessing null content before one can engage in Language.</p>
<p>While the definition of String Length and the first conjunct preclude the inclusion of the Empty Character in a Word, there is no such restriction on the Delimiter, hence the second conjunct of the <a class="reference internal" href="#axiom-w1"><span class="std std-ref">Discovery Axiom</span></a>. This conjunct captures the common-sense notion that a Word from a Language cannot contain a Delimiter; Instead, Delimiters are what separate Words from one another in a String.</p>
<p>It is these two purely syntactical properties that allow a user of Language to separate Words from the arbitrary chaos of Strings, preparing them for the assignment of semantic content.</p>
<section id="theorems">
<span id="word-theorems"></span><h3>Theorems<a class="headerlink" href="#theorems" title="Link to this heading">#</a></h3>
<p>The next theorems establish some basic results about Words in a Language within this formalization. All of these theorems should conform to the common sense notion of Words.</p>
<p id="theorem-1-2-1"><strong>Theorem 1.2.1</strong> <span class="math notranslate nohighlight">\(\forall \alpha \in L:  \alpha \varepsilon = \varepsilon \alpha = \alpha\)</span></p>
<p>This theorem can be stated in natural language as follows: For every Word in a Language, concatenating the Word with the empty String <em>Œµ</em> on either side results in the Word itself.</p>
<p>Let <em>Œ±</em> be an arbitrary word in <strong>L</strong>. By <a class="reference internal" href="#definition-1-2-2"><span class="std std-ref">Definition 1.2.2</span></a>, <em>Œ±</em> is a String of characters. By <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a>, <span class="math notranslate nohighlight">\(l(\alpha)\)</span> is the number of non-Empty Characters in <em>Œ±</em>.</p>
<p>Consider <em>Œµ</em>, the empty string. By <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a>, <span class="math notranslate nohighlight">\(l(\varepsilon) = 0\)</span>. By Definition 1.1.1, the concatenation of any String <em>s</em> with <em>Œµ</em> results in a new string with the same Characters as <em>s</em> in the same order.</p>
<p>Therefore, <em>Œ±Œµ</em> and <em>ŒµŒ±</em> are both Strings with the same Characters as <em>Œ±</em> in the same order. Since <em>Œ±</em> is a Word in <strong>L</strong> and concatenation with <em>Œµ</em> does not change its length or order of Characters. Thus, by <a class="reference internal" href="#definition-1-2-3"><span class="std std-ref">Definition 1.2.3</span></a>,</p>
<div class="math notranslate nohighlight">
\[1. \quad \alpha\varepsilon = \varepsilon\alpha = \alpha.\]</div>
<p>Since <em>Œ±</em> was arbitrary, this can be generalized over the Language,</p>
<div class="math notranslate nohighlight">
\[2. \quad \forall \alpha \in L:  \alpha\varepsilon = \varepsilon\alpha = \alpha\]</div>
<p>‚àé</p>
<p id="theorem-1-2-2"><strong>Theorem 1.2.2</strong> <span class="math notranslate nohighlight">\(\forall \alpha \in L : \forall i \in N_{l(\alpha)}: \alpha[i] \subset_s \alpha\)</span></p>
<p>This theorem can be stated in natural language as follows: All Characters in a Word are contained in the Word.</p>
<p>Assume <em>Œ±</em> is a Word from Language <strong>L</strong>. By the <a class="reference internal" href="#axiom-w1"><span class="std std-ref">Discovery Axiom W.1</span></a>, <span class="math notranslate nohighlight">\(l(\alpha) \neq 0\)</span> and thus it must have at least one non-Empty Character <em>Œ±[i]</em> for some non-zero <em>i</em>.</p>
<p>Consider the String <em>s</em> with a single Character <span class="math notranslate nohighlight">\(\mathfrak{b}_1 = \alpha[i]\)</span>.</p>
<div class="math notranslate nohighlight">
\[1. \quad s = \alpha[i]\]</div>
<p>Clearly, by <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a>, <span class="math notranslate nohighlight">\(l(s) = 1\)</span>. To show that <em>s</em> is contained in <em>Œ±</em>, a strictly increasing and consecutive function that maps the Characters in <em>s</em> to the Characters in <em>Œ±</em> must be found. Since <span class="math notranslate nohighlight">\(l(s) = 1\)</span>, this can be defined simply as,</p>
<div class="math notranslate nohighlight">
\[2. \quad f(1) = i\]</div>
<p>For any value of <em>i</em>. Therefore, by <a class="reference internal" href="#definition-1-1-7"><span class="std std-ref">Definition 1.1.7</span></a>,</p>
<div class="math notranslate nohighlight">
\[3. \quad \alpha[i] \subset_{s} \alpha\]</div>
<p>Since <em>Œ±</em> and <em>i</em> are arbitary, this can be generalized,</p>
<div class="math notranslate nohighlight">
\[4. \quad \forall \alpha \in L : \forall i \in N_{l(\alpha)}: \alpha[i] \subset_{s} \alpha\]</div>
<p>The next theorem, <a class="reference internal" href="#theorem-1-2-3"><span class="std std-ref">Theorem 1.2.3</span></a>, is the direct result of defining String length as the number of non-Empty characters in a String and then defining containment based on String length. Careful inspection of <a class="reference internal" href="#definition-1-1-7"><span class="std std-ref">Definition 1.1.7</span></a> will show that it depends on a precise notion of String Length. In other words, in the current formal system, containment is derivative of length. The order of definitions and axioms in any formal system of Language cannot be of an arbitary character. There is an inherent hierarchical structure in linguistics that must be captured and formalized in the correct order.</p>
<p id="theorem-1-2-3"><strong>Theorem 1.2.3</strong>  <span class="math notranslate nohighlight">\(\forall \alpha \in L : \forall i \in N_{l(\alpha)}: \alpha[i] \neq \varepsilon\)</span></p>
<p>Let <em>Œ±</em> be an arbitrary word in <strong>L</strong>, and let <em>i</em> be a natural number such that,</p>
<div class="math notranslate nohighlight">
\[1. \quad 1 \leq i \leq l(\alpha)\]</div>
<p>By the <a class="reference internal" href="#axiom-w1"><span class="std std-ref">Discovery Axiom W.1</span></a>, it is known that <span class="math notranslate nohighlight">\(l(\alpha) \neq 0\)</span>.</p>
<p>By <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a>, the length of a String is the number of non-Empty Characters it contains in its Character-level set representation <strong>Œë</strong>. Since <span class="math notranslate nohighlight">\(l(\alpha) &gt; 0\)</span>, <em>Œ±</em> must have at least one non-Empty character.</p>
<p>Since <span class="math notranslate nohighlight">\(1 \leq i \leq l(\alpha)\)</span>, the Character at position <em>i</em> in <em>Œ±</em>, denoted <em>Œ±[i]</em>, exists and is non-Empty, <span class="math notranslate nohighlight">\(Œ±[i] \neq \varepsilon\)</span>. Since <em>Œ±</em> and <em>i</em> are arbitrary, this can generalized over the Language,</p>
<div class="math notranslate nohighlight">
\[2. \quad \forall \alpha \in L : \forall i \in N_{l(\alpha)}: \alpha[i] \neq \varepsilon\]</div>
<p>‚àé</p>
<p><a class="reference internal" href="#theorem-1-2-1"><span class="std std-ref">Theorem 1.2.1</span></a> - <a class="reference internal" href="#theorem-1-2-3"><span class="std std-ref">1.2.3</span></a> are the necessary logical pre-conditions for Words to arise from the domain of Strings. In essence, before Language can be distinguished from its uncountably infinite domain, a way of measuring String length must be introduced. This definition must prevent Empty Strings from entering into the Language, which would otherwise allow the annunciation of null content. Then it must be assumed for semantic content to be assigned to a series of concatenated Characters the length of that String must be non-zero. This is the meaning of the first conjunct in the <a class="reference internal" href="#axiom-w1"><span class="std std-ref">Discovery Axiom W.1</span></a>.</p>
<p>Language is materially different from its un-structured domain of Strings for this reason. Language does not possess null content. Language is measureable. Words in Language have String Length. Moreover, Words are delimited. In other words, Words are separable, distinct linguistic entities. These facts are guaranteed by the <a class="reference internal" href="#axiom-w1"><span class="std std-ref">Discovery Axiom W.1</span></a> and <a class="reference internal" href="#theorem-1-2-1"><span class="std std-ref">Theorem 1.2.1</span></a> - <a class="reference internal" href="#theorem-1-2-3"><span class="std std-ref">Theorem 1.2.3</span></a>. These results provide the canvas upon which the rest of the theory will be drawn.</p>
<p>There may appear to be a contradiction in the results of <a class="reference internal" href="#theorem-1-1-3"><span class="std std-ref">Theorem 1.1.3</span></a>, which states the Empty Character is contained in every String, and <a class="reference internal" href="#theorem-1-2-3"><span class="std std-ref">Theorem 1.2.3</span></a>, which states no Character in a Word can be the Empty Character. Every Word is a String, by <a class="reference internal" href="#definition-1-2-2"><span class="std std-ref">Definition 1.2.2</span></a>, so the results appear at odds. The solution to this apparent contradiction lies in how Characters and Strings have been formalized as distinct, but interrelated, terms. The contradiction is no longer a contradiction once the distinction between a String being contained in another String and a Character being a constituent element at a specific position with in a String is understood.</p>
<p>The containment relation <span class="math notranslate nohighlight">\(\varepsilon \subset_s s\)</span> refers to the Empty Character as a subsequence of <em>s</em>. The relation being expressed is about the sequence of Characters, and the Empty sequence is always a subsequence of any other sequence.</p>
<p><a class="reference internal" href="#theorem-1-2-3"><span class="std std-ref">Theorem 1.2.3</span></a>, on the other hand, refers to individual Characters at specific positions within a Word. It is a claim about the elements of the Character-level representation (e.g., the <em>Œπ</em> in <span class="math notranslate nohighlight">\((i, Œπ) \in A\)</span>).</p>
</section>
<section id="string-inversion">
<span id="id5"></span><h3>String Inversion<a class="headerlink" href="#string-inversion" title="Link to this heading">#</a></h3>
<p>Before developing the palindromic structure and symmetries in Words and Language, an operation capable of describing this symmetry much be introduced. Informally, the <em>Inverse</em> of a String is the reversed sequence of Characters in a String. The goal of this section is to define this notion precisely. In the process, the motivation for this definition as it pertains to Words will be elucidated.</p>
<p id="definition-1-2-4"><strong>Definition 1.2.4: String Inversion</strong></p>
<p>Let <em>s</em> be a string with length <em>l(s)</em>. Then, let <em>t</em> be a String with length <em>l(t)</em>.</p>
<p><em>t</em> is called the Inverse of <em>s</em> and is denoted <em>inv(s)</em> if it satisfies the following conditions,</p>
<div class="math notranslate nohighlight">
\[l(t) = l(s)\]</div>
<div class="math notranslate nohighlight">
\[\forall i \in N_{l(s)}: t[i] = s[l(s) - i + 1]\]</div>
<p>‚àé</p>
<p>Note the advantage of Character Index notation in stating this definition. The quantification in the second clause of <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a> can be made directly over the natural numbers, rather than the intermediary of the Character level set representation of <em>t</em> and <em>s</em>.</p>
<p><strong>Example</strong></p>
<p>Let <em>s = ‚Äúabcde‚Äù</em> (<span class="math notranslate nohighlight">\(l(s) = 5\)</span>). Then <span class="math notranslate nohighlight">\(\text{inv}(s) = t = \text{&quot;edcba&quot;}\)</span></p>
<div class="math notranslate nohighlight">
\[t[1] = s[5 - 1 + 1] = s[5] = \text{&quot;e&quot;}\]</div>
<div class="math notranslate nohighlight">
\[t[2] = s[5 - 2 + 1] = s[4] = \text{&quot;d&quot;}\]</div>
<div class="math notranslate nohighlight">
\[t[3] = s[5 - 3 + 1] = s[3] = \text{&quot;c&quot;}\]</div>
<div class="math notranslate nohighlight">
\[t[4] = s[5 - 4 + 1] = s[2] = \text{&quot;b&quot;}\]</div>
<div class="math notranslate nohighlight">
\[t[5] = s[5 - 5 + 1] = s[1] = \text{&quot;a&quot;}\]</div>
<p>‚àé</p>
<p>Since every Word is a String, the Inverse of Word is similarly defined, with the additional constraint that <em>s</em> belong to a Language <strong>L</strong>, i.e. by adding a third bullet to <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a> with <span class="math notranslate nohighlight">\(s \in L\)</span>. The Inverse of a Word is easily understood through a few illustrative examples in English. The following table lists some words in English and their Inverses,</p>
<div class="pst-scrollable-table-container"><table class="table">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Word</p></th>
<th class="head"><p>Inverse</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>time</p></td>
<td><p>emit</p></td>
</tr>
<tr class="row-odd"><td><p>saw</p></td>
<td><p>was</p></td>
</tr>
<tr class="row-even"><td><p>raw</p></td>
<td><p>war</p></td>
</tr>
<tr class="row-odd"><td><p>dog</p></td>
<td><p>god</p></td>
</tr>
<tr class="row-even"><td><p>pool</p></td>
<td><p>loop</p></td>
</tr>
</tbody>
</table>
</div>
<p>However, this particular example is (intentionally) misleading. In this example, the Inverse of a word in English is also a word in English. In general, this property is not exhibited by the majority of Words in any Language. In other words, every Word in an Language has an Inverse but not every Inverse Word belongs to a Language. This phenomenon is exemplified in the following table,</p>
<div class="pst-scrollable-table-container"><table class="table">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Word</p></th>
<th class="head"><p>Inverse</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cat</p></td>
<td><p>x</p></td>
</tr>
<tr class="row-odd"><td><p>you</p></td>
<td><p>x</p></td>
</tr>
<tr class="row-even"><td><p>help</p></td>
<td><p>x</p></td>
</tr>
<tr class="row-odd"><td><p>door</p></td>
<td><p>x</p></td>
</tr>
<tr class="row-even"><td><p>book</p></td>
<td><p>x</p></td>
</tr>
</tbody>
</table>
</div>
<p>The intent is to define a class of Words whose elements belong to it if and only if their Inverse exists in the Language. As a first step towards this definition, String Inversion was introduced and formalized. In the next section, String Inversion will provide a subdomain in the domain of discourse over which to quantify the conditions that are to be imposed on the class of <em>Invertible Words</em>, i.e. the class of Words whose Inverses are also Words.</p>
<p>Note, Invertible Words are often termed <em>semordnilaps</em> in linguistics. The terminology <em>invertible</em> is adopted here to emphasis the structural inversion that is occuring on the Character-level within this class of Words.</p>
<p>Before defining the class of Invertible Words in the sequel, this section is concluded with theorems that strengthen the definition of String Inversion. These theorems will be used extensively in all that follows.</p>
<p id="theorem-1-2-4"><strong>Theorem 1.2.4</strong> <span class="math notranslate nohighlight">\(\forall s \in S: \text{inv}(\text{inv}(s)) = s\)</span></p>
<p>Let <em>s</em> be a String with length <em>l(s)</em> and Characters <em>ùîû</em><sub>i</sub>.</p>
<p>Let <span class="math notranslate nohighlight">\(t = \text{inv}(s)\)</span> with length <em>l(t)</em> and Characters <em>ùîü</em><sub>j</sub>.</p>
<p>By the <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[1. \quad l(t) = l(s)\]</div>
<div class="math notranslate nohighlight">
\[2. \quad \forall i \in N_{l(s)}: t[i] = s[l(s) - i + 1]\]</div>
<p>Now, let <span class="math notranslate nohighlight">\(u = inv(t)\)</span> with length <em>l(u)</em>. Applying <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a> again,</p>
<div class="math notranslate nohighlight">
\[3. \quad l(u) = l(t)\]</div>
<div class="math notranslate nohighlight">
\[4. \quad \forall j \in N_{l(t)}: u[j] = t[l(t) - j + 1]\]</div>
<p>Since <span class="math notranslate nohighlight">\(l(t) = l(s) = l(u)\)</span> and <span class="math notranslate nohighlight">\(N_{l(t)} = N_{l(s)} = N_{l(u)}\)</span> (from step 1, step 3 and by definition of natural numbers), these substitions may be made in step 4,</p>
<div class="math notranslate nohighlight">
\[5. \quad \forall j \in N_{l(s)}: u[j] = s[l(s) - (l(t) - j + 1) + 1]\]</div>
<p>Simplifying the index on the right hand side,</p>
<div class="math notranslate nohighlight">
\[6. \quad \forall j \in N_{l(s)}: u[j] = s[j]\]</div>
<p>Since <em>u</em> and <em>s</em> have the same length (<span class="math notranslate nohighlight">\(l(u) = l(t) = l(s)\)</span>) and the same Characters in the same order (<span class="math notranslate nohighlight">\(u[j] = s[j]\)</span> for all <em>i</em>), by <a class="reference internal" href="#definition-1-1-4"><span class="std std-ref">Definition 1.1.4</span></a> of String Equality, it can be concluded that <span class="math notranslate nohighlight">\(u = s\)</span>. Recall that <span class="math notranslate nohighlight">\(u = \text{inv}(t)\)</span> and <span class="math notranslate nohighlight">\(t = \text{inv}(s)\)</span>. Substituting, the desired result is obtained, <span class="math notranslate nohighlight">\(\text{inv}(\text{inv}(s)) = s\)</span>. ‚àé</p>
<p>Two versions of <a class="reference internal" href="#theorem-1-2-5"><span class="std std-ref">Theorem 1.2.5</span></a> are given, the first using only the Character-level representation of a String, the second using Character Index notation. This is done to show the two formulations are equivalent, and it is a matter of personal preference which style of notation is employed. Throughout the rest of this work, the Character Index notation is primarily utilized, although there are several proofs that are better served by the Character-level representation.</p>
<p id="theorem-1-2-5"><strong>Theorem 1.2.5 (Character-level Representation)</strong> <span class="math notranslate nohighlight">\(\forall u, t \in S: \text{inv}(ut) = \text{inv}(t)\text{inv}(u)\)</span></p>
<p>Let <strong>U</strong> be the Character level representation of <em>u</em>,</p>
<div class="math notranslate nohighlight">
\[1. \quad U = (\mathfrak{a}_1 , \mathfrak{a}_2 , ..., \mathfrak{a}_{l(u)})\]</div>
<p>Let <strong>T</strong> be the Character level representation of <em>t</em>,</p>
<div class="math notranslate nohighlight">
\[2. \quad T = (\mathfrak{b}_1, \mathfrak{b}_2, ... , \mathfrak{b}_{l(t)})\]</div>
<p>The Character level representation of <em>ut</em>, denoted <strong>UT</strong>, is then given by,</p>
<div class="math notranslate nohighlight">
\[3. \quad UT = (\mathfrak{a}_1 , \mathfrak{a}_2 , ..., \mathfrak{a}_{l(u)}, \mathfrak{b}_1, \mathfrak{b}_2 , ... , \mathfrak{b}_{l(t)})\]</div>
<p>By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a> of String Inversion, the Character level representation of <em>inv(ut)</em> is the reversed sequence of <strong>UT</strong>,</p>
<div class="math notranslate nohighlight">
\[4. \quad \text{inv}(UT) = ( \mathfrak{b}_{l(t)}, ..., \mathfrak{b}_2 , \mathfrak{b}_1 , \mathfrak{b}_{l(u)}, ..., \mathfrak{a}_2 , \mathfrak{a}_1)\]</div>
<p>The Character level representation of <em>inv(u)</em>, denoted <strong>inv(U)</strong>,</p>
<div class="math notranslate nohighlight">
\[5. \quad \text{inv}(U) = (\mathfrak{a}_{l(u)}, ..., \mathfrak{a}_2 , \mathfrak{a}_1)\]</div>
<p>The Character-level representation of <em>inv(t)</em>, denoted <strong>inv(T)</strong> is</p>
<div class="math notranslate nohighlight">
\[6. \quad \text{inv}(T) = ( \mathfrak{b}_{l(t)}, ..., \mathfrak{b}_2 , \mathfrak{ùîü}_1 )\]</div>
<p>The Character-level representation of <em>inv(t)inv(u)</em>, denoted <strong>inv(T)inv(U)</strong> is:</p>
<div class="math notranslate nohighlight">
\[7. \quad \text{inv}(T)\text{inv}(U) = ( \mathfrak{b}_{l(t)}, ..., \mathfrak{b}_2 , \mathfrak{b}_1, \mathfrak{a}_{l(u)}, ..., \mathfrak{a}_2 , \mathfrak{a}_1)\]</div>
<p>Comparing the results from step 4 and step 7, it can be seen the Character-level representations of <em>inv(ut)</em> and <em>inv(t)inv(u)</em> are identical.</p>
<p>Therefore, <span class="math notranslate nohighlight">\(\text{inv}(ut) = \text{inv}(t)\text{inv}(u)\)</span>. ‚àé</p>
<p id="theorem-1-2-5-b"><strong>Theorem 1.2.5 (Character Index Notation)</strong>: <span class="math notranslate nohighlight">\(\forall u, t \in S: \text{inv}(ut) = \text{inv}(t)\text{inv}(u)\)</span></p>
<p>Let <em>u</em> and <em>t</em> be arbitrary strings in <strong>S</strong>. Let <span class="math notranslate nohighlight">\(l(u) = m\)</span> and <span class="math notranslate nohighlight">\(l(t) = n\)</span>. Then, <span class="math notranslate nohighlight">\(l(ut) = m + n\)</span>, by <a class="reference internal" href="#definition-1-1-3"><span class="std std-ref">Definition 1.1.3</span></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(s = ut\)</span> . Let <span class="math notranslate nohighlight">\(v = \text{inv}(s) = \text{inv}(ut)\)</span> . Let <span class="math notranslate nohighlight">\(w = \text{inv}(t)\text{inv}(u)\)</span> .</p>
<p>To prove show the theorem, it must be shown that <span class="math notranslate nohighlight">\(v = w\)</span>, which means, by <a class="reference internal" href="#definition-1-1-4"><span class="std std-ref">Definition 1.1.4</span></a>, it must be shown that</p>
<div class="math notranslate nohighlight">
\[1. \quad l(v) = l(w)\]</div>
<div class="math notranslate nohighlight">
\[2. \quad \forall i ‚àà N_{l(v)}: v[i] = w[i]\]</div>
<p>By repeated applications of <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[3. \quad l(v) = l(s) = l(ut) = m + n\]</div>
<div class="math notranslate nohighlight">
\[4. \quad l(\text{inv}(t)) = l(t) = n\]</div>
<div class="math notranslate nohighlight">
\[5. \quad l(\text{inv}(u)) = l(u) = m\]</div>
<p>From step 3 and step 4, it follows,</p>
<div class="math notranslate nohighlight">
\[5. \quad l(w) = l(\text{inv}(t)\text{inv}(u)) = l(\text{inv}(t)) + l(\text{inv}(u)) = n + m = m + n.\]</div>
<p>From steps 4 and 5, it follows,</p>
<div class="math notranslate nohighlight">
\[6. \quad l(v) = l(w) = m + n\]</div>
<p>Now it is to be shown that <span class="math notranslate nohighlight">\(v[i] = w[i]`\)</span> for all <span class="math notranslate nohighlight">\(i \in N_{l(v)}\)</span>. Let <em>i</em> be an arbitrary index such that <span class="math notranslate nohighlight">\(1 \leq i \leq m + n\)</span>.</p>
<p><strong>Case 1</strong>: <span class="math notranslate nohighlight">\(1 \leq i \leq m + n\)</span></p>
<p>By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[a. \quad v[i] = s[l(s) - i + 1]\]</div>
<p>Since <em>l(s) = m + n</em>, it follows,</p>
<div class="math notranslate nohighlight">
\[b. \quad v[i] = s[m + n - i + 1]\]</div>
<p>Since <em>m + n - i + 1</em> corresponds to an index in <em>t</em>, it follows,</p>
<div class="math notranslate nohighlight">
\[c. \quad v[i] = t[n - i + 1]\]</div>
<p>By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[d. \quad v[i] = \text{inv}(t)[i]\]</div>
<p>Since <span class="math notranslate nohighlight">\(w = \text{inv}(t)\text{inv}(u)\)</span>,</p>
<div class="math notranslate nohighlight">
\[e. \quad v[i] = w[i]\]</div>
<p><strong>Case 2</strong>: <span class="math notranslate nohighlight">\(n + 1 \leq i \leq m + n\)</span>:</p>
<p>By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[a. \quad v[i] = s[l(s) - i + 1]\]</div>
<p>Since <span class="math notranslate nohighlight">\(l(s) = m + n\)</span>,</p>
<div class="math notranslate nohighlight">
\[b. \quad v[i] = s[m + n - i + 1]\]</div>
<p>Since <em>m + n - i + 1</em> corresponds to an index in <em>u</em>,</p>
<div class="math notranslate nohighlight">
\[c. \quad v[i] = u[m - (i - n) + 1]\]</div>
<p>Simplifying,</p>
<div class="math notranslate nohighlight">
\[d. \quad v[i] = u[m + n - i + 1]\]</div>
<p>By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[e. \quad v[i] = \text{inv}(u)[i - n]\]</div>
<p>Since <span class="math notranslate nohighlight">\(w = \text{inv}(t)\text{inv}(u)\)</span>,</p>
<div class="math notranslate nohighlight">
\[f. \quad v[i] = w[i] (since w = inv(t)inv(u))\]</div>
<p>In both cases, <span class="math notranslate nohighlight">\(v[i] = w[i]\)</span> for all <span class="math notranslate nohighlight">\(i \in N_{l(v)}\)</span>. Since <span class="math notranslate nohighlight">\(l(v) = l(w)\)</span>, by <a class="reference internal" href="#definition-1-1-4"><span class="std std-ref">Definition 1.1.4</span></a> it follows <span class="math notranslate nohighlight">\(v = w\)</span>. Therefore,</p>
<div class="math notranslate nohighlight">
\[7. \quad \text{inv}(ut) = \text{inv}(t)\text{inv}(u).\]</div>
<p>Since <em>u</em> and <em>t</em> were arbitrary Strings, this can generalize over the set of all Strings,</p>
<div class="math notranslate nohighlight">
\[8. \quad \forall u, t \in S: \text{inv}(ut) = \text{inv}(t)\text{inv}(u) ‚àé\]</div>
<p>The next theorem establishes the <em>‚Äúdistributivity‚Äù</em> of String inversion over the relation of containment.</p>
<p id="theorem-1-2-6"><strong>Theorem 1.2.6</strong> <span class="math notranslate nohighlight">\(\forall u, t \in S : u \subset_s t \leftrightarrow \text{inv}(u) \subset_s \text{inv}(t)\)</span></p>
<p>This theorem can be stated in natural language as follows: For any two Strings <em>u</em> and <em>t</em>, <em>u</em> is contained in <em>t</em> if and only if the Inverse of <em>u</em> is contained in the Inverse of <em>t</em>.</p>
<p>Let <em>u</em> and <em>t</em> be arbitrary Strings in <strong>S</strong>.</p>
<p>(‚Üí) Assume,</p>
<div class="math notranslate nohighlight">
\[1. \quad u \subset_s t\]</div>
<p>By <a class="reference internal" href="#definition-1-1-7"><span class="std std-ref">Definition 1.1.7</span></a>, there exists a strictly increasing and consecutive function <span class="math notranslate nohighlight">\(f: N_{l(u)} \to N_{l(t)}\)</span> such that,</p>
<div class="math notranslate nohighlight">
\[1. \quad \forall i \in N_{l(u)}: u[i] = t[f(i)]\]</div>
<p>Let,</p>
<div class="math notranslate nohighlight">
\[3. \quad v = \text{inv}(t)\]</div>
<div class="math notranslate nohighlight">
\[4. \quad w = \text{inv}(u).\]</div>
<p>By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[5. \quad \forall i \in N_{l(u)}: w[i] = \text{inv}(u)[i] = u[l(u) - i + 1]\]</div>
<div class="math notranslate nohighlight">
\[6. \quad \forall i \in N_{l(t)}: v[i] = \text{inv}(t)[i] = t[l(t) - i + 1]\]</div>
<p>Define a function <span class="math notranslate nohighlight">\(g: N_{l(w)} \to N_{l(v)}\)</span>  as follows,</p>
<div class="math notranslate nohighlight">
\[7. \quad g(i) = l(t) - f(l(u) - i + 1) + 1\]</div>
<p>This function maps the Character indices of <em>w</em> (the inverse of <em>u</em>) to the indices of <em>v</em> (the inverse of <em>t</em>).</p>
<p><strong>Increasing</strong> To show <em>g</em> is strictly increasing, let</p>
<div class="math notranslate nohighlight">
\[8. \quad i, j \in N_{l(w)}\]</div>
<p>Such that <span class="math notranslate nohighlight">\(i &lt; j\)</span>. Since <span class="math notranslate nohighlight">\(l(w) = l(u)\)</span>,</p>
<div class="math notranslate nohighlight">
\[9. \quad i, j \in N_{l(u)}\]</div>
<p>Because <em>f</em> is strictly increasing, and</p>
<div class="math notranslate nohighlight">
\[10. \quad l(u) - j + 1 &lt; l(u) - i + 1,\]</div>
<p>It follows,</p>
<div class="math notranslate nohighlight">
\[11. \quad f(l(u) - j + 1) &lt; f(l(u) - i + 1)\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[12. \quad l(t) - f(l(u) - i + 1) + 1 &lt; l(t) - f(l(u) - j + 1) + 1\]</div>
<p>which means</p>
<div class="math notranslate nohighlight">
\[13. \quad g(i) &lt; g(j).\]</div>
<p>Thus, <em>g</em> is strictly increasing.</p>
<p><strong>Consecutive</strong> To show <em>g</em> is consecutive, let</p>
<div class="math notranslate nohighlight">
\[14. \quad i \in N_{l(w)}\]</div>
<p>Such that <span class="math notranslate nohighlight">\(i &lt; l(w)\)</span>. Then,</p>
<div class="math notranslate nohighlight">
\[15. \quad g(i+1) = l(t) - f(l(u) - (i + 1) + 1) + 1\]</div>
<div class="math notranslate nohighlight">
\[16. \quad g(i+1) = l(t) - f(l(u) - i - 1 + 1) + 1\]</div>
<p>Since <em>f</em> is consecutive, we have:</p>
<div class="math notranslate nohighlight">
\[17. \quad f(l(u) - i - 1 + 1) = f(l(u) - i) + 1\]</div>
<p>Then,</p>
<div class="math notranslate nohighlight">
\[18. \quad g(i+1) = l(t) - (f(l(u) - i) + 1) + 1\]</div>
<div class="math notranslate nohighlight">
\[19. \quad g(i+1) = l(t) - f(l(u) - i)\]</div>
<div class="math notranslate nohighlight">
\[20. \quad g(i+1) = l(t) - f(l(u) - i + 1) + 1 + 1 - 1\]</div>
<div class="math notranslate nohighlight">
\[21. \quad g(i+1) = l(t) - f(l(u) - i + 1) + 1\]</div>
<div class="math notranslate nohighlight">
\[22. \quad g(i+1) = g(i) + 1\]</div>
<p>Thus <em>g</em> is consecutive.</p>
<p><strong>Containment</strong> Now, it must shown be that,</p>
<div class="math notranslate nohighlight">
\[23. \quad \forall i \in N_{l(w)}: w[i] = v[g(i)]\]</div>
<p>By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[24. \quad w[i] = u[l(u) - i + 1]\]</div>
<p>From step 2, it follows,</p>
<div class="math notranslate nohighlight">
\[25. \quad w[i] = t[f(l(u) - i + 1)]\]</div>
<p>By definition of <em>g</em>,</p>
<div class="math notranslate nohighlight">
\[26. \quad g(i) = l(t) - f(l(u) - i + 1) + 1\]</div>
<p>Rearranging,</p>
<div class="math notranslate nohighlight">
\[27. \quad f(l(u) - i + 1) = l(t) - g(i) + 1\]</div>
<p>Substituting into step 25,</p>
<div class="math notranslate nohighlight">
\[28. \quad w[i] = t[l(t) - g(i) + 1]\]</div>
<p>By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a> and the definition of <em>v</em>,</p>
<div class="math notranslate nohighlight">
\[29. \quad v[g(i)] = t[l(t) - g(i) + 1]\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[30. \quad w[i] = v[g(i)]\]</div>
<p>Since this holds for all <span class="math notranslate nohighlight">\(i \in N_{l(w)}\)</span>, and <em>g</em> is a strictly increasing and consecutive function, by <a class="reference internal" href="#definition-1-1-7"><span class="std std-ref">Definition 1.1.7</span></a>, it follows,</p>
<div class="math notranslate nohighlight">
\[31. \quad w \subset_s v\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[32. \quad \text{inv}(u) \subset_s \text{inv}(t)\]</div>
<p>(‚Üê) Assume</p>
<div class="math notranslate nohighlight">
\[1. \quad \text{inv}(u) \subset_s \text{inv}(t)\]</div>
<p>By <a class="reference internal" href="#theorem-1-2-4"><span class="std std-ref">Theorem 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[2. \quad \text{inv}(\text{inv}(u)) = u\]</div>
<div class="math notranslate nohighlight">
\[3. \quad \text{inv}(\text{inv}(t)) = t\]</div>
<p>Therefore, using the result just proved in the (‚Üí) direction, it can be said since</p>
<div class="math notranslate nohighlight">
\[4. \quad \text{inv}(u) \subset_s \text{inv}(t)\]</div>
<p>This implies,</p>
<div class="math notranslate nohighlight">
\[5. \quad \text{inv}(\text{inv}(t)) \subset_s \text{inv}(\text{inv}(u))\]</div>
<p>Substituting in steps 2 and 3,</p>
<div class="math notranslate nohighlight">
\[6. \quad t \subset_s u\]</div>
<p>Since both directions of the implication hold, it follows,</p>
<div class="math notranslate nohighlight">
\[1. \quad \forall u, t \in S: u \subset_s t \leftrightarrow \text{inv}(u) \subset_s \text{inv}(t) ‚àé\]</div>
<p>The next theorem establishes the <em>transitivity</em> of containment over Strings.</p>
<p id="theorem-1-2-7"><strong>Theorem 1.2.7</strong> <span class="math notranslate nohighlight">\(\forall t, u, v \in S : (t \subset_s u) \land (u \subset_s v) \to (t \subset_s v)\)</span></p>
<p>This theorem can be stated in natural language as follows: For any Strings <em>t</em>, <em>u</em>, and <em>v</em> in <strong>S</strong>, if <em>t</em> is contained in <em>u</em> and <em>u</em> is contained in <em>v</em>, then <em>t</em> is contained in <em>v</em>.</p>
<p>Let <em>t</em>, <em>u</em>, and <em>v</em> be arbitrary Strings in <strong>S</strong> such that both of the following expressions are true,</p>
<div class="math notranslate nohighlight">
\[1. \quad t \subset_s u\]</div>
<div class="math notranslate nohighlight">
\[2. \quad u \subset_s v\]</div>
<p>By <a class="reference internal" href="#definition-1-1-7"><span class="std std-ref">Definition 1.1.7</span></a> and step 1, there exists a strictly increasing and consecutive function <span class="math notranslate nohighlight">\(f: N_{l(t)} \to N_{l(u)}\)</span> such that,</p>
<div class="math notranslate nohighlight">
\[3. \quad \forall i \in N_{l(t)}: t[i] = u[f(i)]\]</div>
<p>Similarly, by <a class="reference internal" href="#definition-1-1-7"><span class="std std-ref">Definition 1.1.7</span></a> and step 2, there exists a strictly increasing and consecutive function <span class="math notranslate nohighlight">\(g: N_{l(u)} \to N_{l(v)}\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[4. \quad \forall j \in N_{l(u)}: u[j] = v[g(j)]\]</div>
<p>Define a new function <span class="math notranslate nohighlight">\(h: N_{l(t)} \to N_{l(v)}\)</span> as the composition of <em>f</em> and <em>g</em>,</p>
<div class="math notranslate nohighlight">
\[5. \quad \forall j \in N_{l(t)}: h(i) = g(f(i))\]</div>
<p><strong>Increasing</strong> Let</p>
<div class="math notranslate nohighlight">
\[6. \quad i, j \in N_{l(t)}\]</div>
<p>Such that <span class="math notranslate nohighlight">\(i &lt; j\)</span>. Since <em>f</em> is strictly increasing,</p>
<div class="math notranslate nohighlight">
\[7. \quad f(i) &lt; f(j)\]</div>
<p>Since <em>g</em> is strictly increasing,</p>
<div class="math notranslate nohighlight">
\[8. \quad g(f(i)) &lt; g(f(j))\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[9. \quad h(i) &lt; h(j)\]</div>
<p>Thus, <em>h</em> is strictly increasing.</p>
<p><strong>Consecutive</strong> Let</p>
<div class="math notranslate nohighlight">
\[10. \quad i \in N_{l(t)}\]</div>
<p>Such that <span class="math notranslate nohighlight">\(i &lt; l(t)\)</span>. Since <em>f</em> is consecutive,</p>
<div class="math notranslate nohighlight">
\[11. \quad f(i+1) = f(i) + 1\]</div>
<p>Since <em>g</em> is consecutive, following from step 11,</p>
<div class="math notranslate nohighlight">
\[12. \quad g(f(i+1)) = g(f(i) + 1) = g(f(i)) + 1\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[13. \quad h(i+1) = h(i) + 1\]</div>
<p>Thus, <em>h</em> is consecutive.</p>
<p><strong>Containment</strong> Let</p>
<div class="math notranslate nohighlight">
\[14. \quad i \in N_{l(t)}\]</div>
<p>Then, by step 3</p>
<div class="math notranslate nohighlight">
\[15. \quad t[i] = u[f(i)]\]</div>
<p>Since <span class="math notranslate nohighlight">\(f: N_{l(t)} \to N_{l(u)}\)</span>, it follows that for all</p>
<div class="math notranslate nohighlight">
\[16. \quad \forall i \in N_{l(t)}: f(i) \in N_{l(u)}`\]</div>
<p>By step 16 and step 4,</p>
<div class="math notranslate nohighlight">
\[17. \quad u[f(i)] = v[g(f(i))]\]</div>
<p>By definition of <em>h</em>,</p>
<div class="math notranslate nohighlight">
\[18. \quad v[g(f(i))] = v[h(i)]\]</div>
<p>Therefore,</p>
<div class="math notranslate nohighlight">
\[19. \quad \forall i \in N_l(t): t[i] = v[h(i)]\]</div>
<p>Since <em>h</em> is a strictly increasing and consecutive function over <span class="math notranslate nohighlight">\(N:sub:`l(t) \to N_{l(v)}\)</span>, and <span class="math notranslate nohighlight">\(t[i] = v[h(i)]\)</span> for all <span class="math notranslate nohighlight">\(1 \leq i \leq l(t)\)</span>, by <a class="reference internal" href="#definition-1-1-7"><span class="std std-ref">Definition 1.1.7</span></a>,</p>
<div class="math notranslate nohighlight">
\[20. \quad t \subset_s v.\]</div>
<p>Since <em>t</em>, <em>u</em>, and <em>v</em> were arbitrary Strings, this can be generalized over the set of all Strings,</p>
<div class="math notranslate nohighlight">
\[21. \quad \forall t, u, v \in S : (t \subset_s u) \land (u ‚äÇ:sub:`s` v) \to (t subset_s v) ‚àé\]</div>
</section>
<section id="phrases">
<span id="id6"></span><h3>Phrases<a class="headerlink" href="#phrases" title="Link to this heading">#</a></h3>
<p>While the analyis has not yet introduced the notion of Sentences into the formal system (see Section II), an operation will now be introduced that allows Words to be ordered into Phrases and then concatenated into Strings. This new operation will be important when String Inversion is applied to the sentential level of the formal system, allowing the conditions for a Sentence Inversion to be precisely specified.</p>
<p>The placement of <a class="reference internal" href="#definition-1-2-5"><span class="std std-ref">Definition 1.2.5</span></a> and <a class="reference internal" href="#definition-1-2-6"><span class="std std-ref">Definition 1.2.6</span></a> is somewhat arbitary. There are valid arguments to be made for placing these definitions after the concepts of Sentence and Word Index notation have been introduced in <a class="reference internal" href="03_corpora.html#section-ii"><span class="std std-ref">Section II</span></a>. However, since the operation of <em>Delimitation</em> and <em>Limitations</em> to be expounded immediately are essentially an operation defined on the domain of Strings which yields as a result another String, i.e. Delimitation and Limitation are closed with respect to Strings, the definitions are made here, to highlight the derivative notions (Inversion, Delimitation and Limitations) which can be built on top of the primitive notion of concatenation.</p>
<p id="definition-1-2-5"><strong>Definition 1.2.5: Phrase</strong></p>
<p>Let <em>n</em> be a fixed, non-zero natural number, <span class="math notranslate nohighlight">\(n \geq 1\)</span>. A Phrase of Word Length <em>n</em> from Language <strong>L</strong>, denoted <strong>P</strong><sub>n</sub>, is defined as an ordered sequence of <em>n</em> (not necessarily distinct) Words,</p>
<div class="math notranslate nohighlight">
\[P_n = (\alpha_1, \alpha_2, ... , \alpha_n)\]</div>
<p>where each <span class="math notranslate nohighlight">\(\alpha_i \in L\)</span>. If <em>i</em> is such that <span class="math notranslate nohighlight">\(1 \leq i \leq n\)</span>, <span class="math notranslate nohighlight">\(P_n(i)\)</span> denotes the Word <em>Œ±</em><sub>i</sub> at index <em>i</em>, so that <strong>P</strong><sub>n</sub> may be rewritten,</p>
<div class="math notranslate nohighlight">
\[P_n = (P_n(1), P_n(2), ... , P_n(n))\]</div>
<p>When <span class="math notranslate nohighlight">\(n = 0\)</span>, <strong>P</strong><sub>0</sub> is defined as the empty sequence (). ‚àé</p>
<p>In order to establish some properties of Phrases, Delimitations and Limitations , a symbol for representing the range of a Phrase <strong>P</strong><sub>n</sub> over a Language <strong>L</strong> is now defined.</p>
<p id="definition-1-2-6"><strong>Definition 1.2.6: Lexicon</strong></p>
<p>Let <em>n</em> be a fixed natural number. We define a Language‚Äôs <em>n</em><sup>th</sup> Lexicon, denoted <span class="math notranslate nohighlight">\(X_L(n)\)</span>, as the set of all Phrases of length <em>n</em> formed from Words in <strong>L</strong>,</p>
<div class="math notranslate nohighlight">
\[X_{L}(n) = \{ P_n \mid P_n = (\alpha_1, \alpha_2, ..., \alpha_n) \land \forall i \in N_n: \alpha_i \in L \}\]</div>
<p>‚àé</p>
<p>Some of the later theorems in this work will require quantifying over Phrases in a Language‚Äôs <em>n</em><sub>th</sub> Lexicon, so notation is introduced for Phrase Variables,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Phrase Variables (<em>p</em>, <em>q</em>, <em>r</em>): The lowercase English letters <em>p</em>, <em>q</em>, <em>r</em> are reserved for representing indeterminate Phrases of a Language‚Äôs <em>n</em><sup>th</sup> Lexicon.</p></li>
</ol>
</div></blockquote>
<p>Because Phrases are ordered sequences of Words, the Phrase Variable <em>p(i)</em> will denote, exactly like the Definition of a Phrase, the Word at index <em>i</em> for <span class="math notranslate nohighlight">\(1 \leq i \leq n\)</span>.</p>
<p>Using these pair of definitions for Phrases and Lexicons and their associated terminology, the operation of <em>Delimitation</em> is now defined over Phrases of fixed Word Length <em>n</em> in <a class="reference internal" href="#definition-1-2-7"><span class="std std-ref">Definition 1.2.7</span></a>.</p>
<p id="definition-1-2-7"><strong>Definition 1.2.7: Delimitation</strong></p>
<p>Let <em>p</em> be a Phrase from a Language <strong>L</strong>‚Äôs <em>n</em><sup>th</sup> Lexicon,</p>
<div class="math notranslate nohighlight">
\[p = (\alpha_1, \alpha_2, ... , \alpha_n)\]</div>
<p>The <em>Delimitation</em> of <em>p</em>, denoted <span class="math notranslate nohighlight">\(D\Pi_{i=1}^{n} p(i)\)</span>, is defined recursively as:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Empty Clause: <span class="math notranslate nohighlight">\(D\Pi_{i=1}^{0} p(i) = \varepsilon\)</span></p></li>
<li><p>Basis Clause (<span class="math notranslate nohighlight">\(n = 1\)</span>): <span class="math notranslate nohighlight">\(D\Pi_{i=1}^{1} p(i) = \alpha_1\)</span></p></li>
<li><p>Recursive Clause (<span class="math notranslate nohighlight">\(n &gt; 1\)</span>): <span class="math notranslate nohighlight">\(D\Pi_{i=1}^{n} p(i) = (D\Pi_{i=1}^{n-1} p(i))(\sigma)(\alpha_n)\)</span></p></li>
</ol>
</div></blockquote>
<p>‚àé</p>
<p id="definition-1-2-8"><strong>Definition 1.2.8: Limitation</strong></p>
<p>Let <em>p</em> be a Phrase from a Language <strong>L</strong>‚Äôs <em>n</em><sup>th</sup> Lexicon,</p>
<div class="math notranslate nohighlight">
\[p = (\alpha_1, \alpha_2, ..., \alpha_n)\]</div>
<p>The <em>Limitation</em> of <em>p</em>, denoted <span class="math notranslate nohighlight">\(L\Pi_{i=1}^{n} p(i)\)</span>, is defined recursively as:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Empty Clause: <span class="math notranslate nohighlight">\(L\Pi_{i=1}^{0} p(i) = \varepsilon\)</span></p></li>
<li><p>Basis Clause (<span class="math notranslate nohighlight">\(n = 1\)</span>): <span class="math notranslate nohighlight">\(L\Pi_{i=1}^{1} p(i) = \alpha_1\)</span></p></li>
<li><p>Recursive Clause (<span class="math notranslate nohighlight">\(n &gt; 1\)</span>): <span class="math notranslate nohighlight">\(L\Pi_{i=1}^{n} p(i) = (L\Pi_{i=1}^{n-1} p(i)(\alpha_n)\)</span></p></li>
</ol>
</div></blockquote>
<p>‚àé</p>
<p>The key difference between <a class="reference internal" href="#definition-1-2-7"><span class="std std-ref">Definition 1.2.7</span></a> and <a class="reference internal" href="#definition-1-2-8"><span class="std std-ref">Definition 1.2.8</span></a> is the presence of the Delimiter in the Recursive Clause. In other words, a Delimitation inserts a Delimiter between the Words it is concatenating, while a Limitation is simply a shorthand simply for concatenating a sequence of Words.</p>
<p>Before proving the existence of Delimitations and Limitations, an example of how they are constructed recursively is given below.</p>
<p><strong>Example</strong></p>
<p>Let</p>
<div class="math notranslate nohighlight">
\[1. \quad P_3 = (\text{&quot;mother&quot;}, \text{&quot;may&quot;}, \text{&quot;I&quot;})\]</div>
<p>Apply <a class="reference internal" href="#definition-1-2-7"><span class="std std-ref">Definition 1.2.7</span></a> to construct the Delimitation of <strong>P</strong><sub>3</sub>. The Basis Step yields,</p>
<div class="math notranslate nohighlight">
\[2. \quad n = 1: D\Pi_{i=1}^{1} \alpha_i = \text{&quot;mother&quot;}\]</div>
<p>And then the Delimitation can be built up recursively using the Recursive Step repeatedly,</p>
<div class="math notranslate nohighlight">
\[3.  \quad n = 2: D\Pi_{i=1}^{2} \alpha_i = (D\Pi_{i=1}^{1} \alpha_i)(\sigma)(\text{&quot;may&quot;})= (\text{&quot;mother&quot;})(\sigma\text{&quot;may&quot;}) = \text{&quot;mother&quot;}\sigma\text{&quot;may&quot;}\]</div>
<div class="math notranslate nohighlight">
\[4.  \quad n = 3: D\Pi_{i=1}^{3} \alpha_i = (D\Pi_{i=1}^{2} \alpha_i)(\sigma)(\text{&quot;I&quot;}) = (\text{&quot;mother&quot;}\sigma\text{&quot;may&quot;})(\sigma\text{&quot;I&quot;}) = \text{&quot;mother&quot;}\sigma\text{&quot;may&quot;}\sigma\text{&quot;I&quot;}\]</div>
<p>So the Delimitation of the Phrase is given by,</p>
<div class="math notranslate nohighlight">
\[4. \quad D\Pi_{i=1}^{3} \alpha_i = \text{&quot;mother may I&quot;}\]</div>
<p>Similarly, the Limitation can be constructed recursive from the same Basis Step using <a class="reference internal" href="#definition-1-2-8"><span class="std std-ref">Definition 1.2.8</span></a>,</p>
<div class="math notranslate nohighlight">
\[5. \quad n = 2: L\Pi_{i=1}^{2} \alpha_i = (L\Pi_{i=1}^{1} \alpha_i)(\text{&quot;may&quot;})= (\text{&quot;mother&quot;})(\text{&quot;may&quot;}) = \text{&quot;mothermay&quot;}\]</div>
<div class="math notranslate nohighlight">
\[6. \quad n = 3: L\Pi_{i=1}^{3} \alpha_i = (L\Pi_{i=1}^{2} \alpha_i)(\text{&quot;I&quot;}) = (\text{&quot;mothermay&quot;})(\text{&quot;I&quot;}) = \text{&quot;mothermayI&quot;}\]</div>
<p>‚àé</p>
<p>From this example, it should be clear what the Delimitation and Limitation operations represent within the formal system. Delimitation is a method of constructing a Sentence-like (see Section II.III for the formal difference between a Delimitation and Sentence) String from a sequence of words, while a Limitation is shorthand for iterated concatenation over a sequence of Words.</p>
<p>Note the previous example may be misleading in one important respect. A Delimitation is not necessarily ‚Äúgrammatical‚Äù or ‚Äúmeaningful‚Äù. It may be a String of semantic Words without an accompanying interpretation on the Sentence level of the linguistic hierarchy.</p>
<p>However, as the next theorems shows, the result of a Delimitation or Limitation is unique.</p>
<p id="theorem-1-2-8"><strong>Theorem 1.2.8</strong> <span class="math notranslate nohighlight">\(\forall n \in \mathbb{N}: \forall p \in X_{L(n)}: \exists! s \in S: s = D\Pi_{i=1}^{n} p(i)\)</span></p>
<p>This theorem can be stated in natural language as follows: For every natural number n, and for every Phrase <strong>P</strong><sub>n</sub> in the <em>n</em><sup>th</sup> Lexicon of <strong>L</strong>, there exists a unique string <em>s</em> in <strong>S</strong> such that <em>s</em> is the Delimitation of <strong>P</strong><sub>n</sub>.</p>
<p>Let <em>n</em> be an arbitrary natural number, and let <strong>P</strong><sub>n</sub> be a Phrase of Word Length <em>n</em> in Language <strong>L</strong> from the Language‚Äôs <em>n</em><sup>th</sup> Lexicon, <span class="math notranslate nohighlight">\(X_L(n)\)</span>,</p>
<div class="math notranslate nohighlight">
\[1. \quad P_n = (\alpha_1, \alpha_2, ..., \alpha_n)\]</div>
<p>The theorem will be proved using induction.</p>
<p><strong>Base Case</strong> <span class="math notranslate nohighlight">\(n = 1\)</span></p>
<p>By <a class="reference internal" href="#definition-1-2-7"><span class="std std-ref">Definition 1.2.7</span></a>,</p>
<div class="math notranslate nohighlight">
\[2. \quad D\Pi_{i=1}^{1} P_{n}(i) = \alpha_1\]</div>
<p>Since <em>Œ±</em><sub>1</sub> is a word in <strong>L</strong> (by <a class="reference internal" href="#definition-1-2-6"><span class="std std-ref">Definition 1.2.6</span></a> of Lexicon), it is also a String in S (by <a class="reference internal" href="#definition-1-2-2"><span class="std std-ref">Definition 1.2.2</span></a>). Thus, there exists a String <span class="math notranslate nohighlight">\(s = \alpha_1\)</span> such that</p>
<div class="math notranslate nohighlight">
\[3. \quad s = D\Pi_{i=1}^{1} P_{n(i)}\]</div>
<p>Since the base case of Delimitation is defined as simple equality, the string s must be unique.</p>
<p><strong>Inductive Hypothesis</strong></p>
<p>Assume that for some <em>k ‚â• 1</em>, there exists a unique string <em>s</em><sub>k</sub> such that</p>
<div class="math notranslate nohighlight">
\[4. \quad s_k = D\Pi_{i=1}^{k} P_n(i)\]</div>
<p>To complete the induction, it must be shown that there exists a unique string <em>s</em><sub>k+1</sub> such that,</p>
<div class="math notranslate nohighlight">
\[5. \quad s_{k+1} = D\Pi_{i=1}^{k+1} P_n (i)\]</div>
<p>By <a class="reference internal" href="#definition-1-2-7"><span class="std std-ref">Definition 1.2.7</span></a>,</p>
<div class="math notranslate nohighlight">
\[6. \quad D\Pi_{i=1}^{k+1} P_n(i) = (D\Pi_{i=1}^{k} P_n(i))(\sigma)(\alpha_{k+1})\]</div>
<p>By inductive hypothesis,</p>
<div class="math notranslate nohighlight">
\[7. \quad D\Pi_{i=1}^{k} P_n(i) = s_k\]</div>
<p>Thus, <em>s</em><sub>k</sub> is unique. Since <em>Œ±</em><sub>k+1</sub> is a Word in <strong>L</strong> (by the definition of <span class="math notranslate nohighlight">\(X_L (n+1)\)</span>), it is also a unique String in <strong>S</strong>.</p>
<p>The concatenation of <em>s</em><sub>k</sub>, <em>œÉ</em>, and <em>Œ±</em><sub>k+1</sub> is a unique string (by the <a class="reference internal" href="#definition-1-1-1"><span class="std std-ref">Definition 1.1.1</span></a> of Concatenation and <a class="reference internal" href="#definition-1-1-4"><span class="std std-ref">Definition 1.1.4</span></a> of String Equality).</p>
<p>Therefore, <span class="math notranslate nohighlight">\(s_{k+1} = (s-k)(\sigma)(\alpha_{k+1})\)</span> is a unique string.</p>
<p>By induction, for every natural number <em>n</em>, and for every phrase <strong>P</strong><sub>n</sub> in <span class="math notranslate nohighlight">\(X_L (n)\)</span>, there exists a unique string <em>s</em> in <strong>S</strong> such that</p>
<div class="math notranslate nohighlight">
\[8. \quad s = D\Pi_{i=1}^{n} P_n (i)\]</div>
<p>‚àé</p>
<p id="theorem-1-2-9"><strong>Theorem 1.2.9</strong> <span class="math notranslate nohighlight">\(\forall n \in \mathbb{N}: \forall p \in X_L(n): \exists! s \in S: s = L\Pi_{i=1}^{n} p(i)\)</span></p>
<p>The proof of this theorem is almost exactly identical to <a class="reference internal" href="#theorem-1-2-8"><span class="std std-ref">Theorem 1.2.8</span></a>, with the exception there is no Delimiter in step 6. ‚àé</p>
</section>
</section>
<section id="section-i-iii-word-classes">
<span id="section-i-iii"></span><h2>Section I.III: Word Classes<a class="headerlink" href="#section-i-iii-word-classes" title="Link to this heading">#</a></h2>
<p>It will be necessary to define special classes of Words in a Language to properly describe the Language‚Äôs palindromic structure. These classes, especially the class of Invertible Words, will be used extensively in the next sections. Reflective Words, however, will play a crucial role in this work‚Äôs climatic theorem.</p>
<section id="reflective-words">
<span id="id7"></span><h3>Reflective Words<a class="headerlink" href="#reflective-words" title="Link to this heading">#</a></h3>
<p>The concept of <em>Reflective Words</em> can be easily understood by examining some examples in English,</p>
<div class="pst-scrollable-table-container"><table class="table">
<colgroup>
<col style="width: 100.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Word</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>mom</p></td>
</tr>
<tr class="row-odd"><td><p>dad</p></td>
</tr>
<tr class="row-even"><td><p>noon</p></td>
</tr>
<tr class="row-odd"><td><p>racecar</p></td>
</tr>
<tr class="row-even"><td><p>madam</p></td>
</tr>
<tr class="row-odd"><td><p>level</p></td>
</tr>
<tr class="row-even"><td><p>civic</p></td>
</tr>
</tbody>
</table>
</div>
<p>From this list, it should be clear what is meant by the notion of <em>reflective</em>. Reflective Words are those Words whose meaning is unchanged by a String Inversion. However, the semantic content that is preserved under inversion is not the primitive property that primarily explains this invariance. The invariance of the semantic content under inversion is the result of Character level symmetries.</p>
<p>Rather than attempt to define Reflective Words as the class of Words that are their own Inverses, a different approach will be taken that highlights the Character level symmetries that exist in these class of Words. It will then be proven the class of Words which satisfy this definition are exactly those Words that are their own Inverses.</p>
<p id="definition-1-3-1"><strong>Definition 1.3.1: Reflective Words</strong></p>
<p>The set of Reflective Words <strong>R</strong> is defined as the set of <em>Œ±</em> which satisfy the open formula,</p>
<div class="math notranslate nohighlight">
\[\alpha \in R \leftrightarrow \forall i \in \mathbb{N}_{l(\alpha)}: \alpha[i] = \alpha[l(\alpha) - i + 1]\]</div>
<p>‚àé</p>
<p>A Word <em>Œ±</em> will be referred to as <em>reflective</em> if it belongs to the class of Reflective Words.</p>
<p>The following theorem is an immediate consequence of <a class="reference internal" href="#definition-1-3-1"><span class="std std-ref">Definition 1.3.1</span></a> and <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>.</p>
<p id="theorem-1-3-1"><strong>Theorem 1.3.1</strong> <span class="math notranslate nohighlight">\(\forall \alpha \in L: \alpha \in R \leftrightarrow \alpha = \text{inv}(\alpha)\)</span></p>
<p>In natural language, this theorem can be stated as: A Word in a Language is Reflective if and only if it is its own Inverse.</p>
<p>(‚Üí)  Assume <span class="math notranslate nohighlight">\(\alpha \in R\)</span>. By <a class="reference internal" href="#definition-1-3-1"><span class="std std-ref">Definition 1.3.1</span></a>,</p>
<div class="math notranslate nohighlight">
\[1. \quad \forall i \in N_{l(\alpha)}:  \alpha[i] = \alpha[l(\alpha) - i + 1]\]</div>
<p>Let <span class="math notranslate nohighlight">\(\beta = \text{inv}(\alpha)\)</span>. By the <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[2. \quad l(\beta) = l(\alpha)\]</div>
<div class="math notranslate nohighlight">
\[3. \quad \forall i \in N_{l(Œ±)}: ( \beta[i] = \alpha[l(\alpha) - i + 1] )\]</div>
<p>Substituting the property of Reflective Words from step 1 into step 3,</p>
<div class="math notranslate nohighlight">
\[4. \quad \forall i \in N_{l(\alpha)}: \beta[i] = \alpha[i]\]</div>
<p>Since <span class="math notranslate nohighlight">\(\beta[i] = \alpha[i]\)</span> for all <span class="math notranslate nohighlight">\(i \in N_{l(\alpha)}\)</span>, and both strings have the same length, by <a class="reference internal" href="#definition-1-1-4"><span class="std std-ref">Definition 1.1.4</span></a>, it can be concluded that <span class="math notranslate nohighlight">\(\alpha = \beta\)</span>. Therefore the desired result is obtained, <span class="math notranslate nohighlight">\(\alpha = \beta = \text{inv}(\alpha)\)</span>.</p>
<p>(‚Üê) Assume <span class="math notranslate nohighlight">\(\alpha = \text{inv}(\alpha)\)</span>.  By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a> of String Inversion,</p>
<div class="math notranslate nohighlight">
\[1. \quad l(\alpha) = l(\text{inv}(\alpha))\]</div>
<div class="math notranslate nohighlight">
\[2. \quad \forall i \in N_{l(\alpha)}: \alpha[i] = \alpha[l(\alpha) - i + 1]\]</div>
<p>But step 2 is exactly the definition of Reflective Words, so by <a class="reference internal" href="#definition-1-3-1"><span class="std std-ref">Definition 1.3.1</span></a>, <span class="math notranslate nohighlight">\(\alpha \in R\)</span> ‚àé</p>
</section>
<section id="invertible-words">
<span id="id8"></span><h3>Invertible Words<a class="headerlink" href="#invertible-words" title="Link to this heading">#</a></h3>
<p>As discussed previously, the concept of <em>invertible</em> is exemplified in pairs of English words, such as <em>‚Äúparts‚Äù</em> and <em>‚Äústrap‚Äù</em>, or <em>‚Äúrepaid‚Äù</em> and <em>‚Äúdiaper‚Äù</em>. If a Word can be inverted, this is not simply a syntactic operation, but a semantic one as well. An <em>Invertible Word</em> is a Word whose inverse is part of the same Language <strong>L</strong> as the original Word. This notion can now be made more precise with the terminology introduced in prior sections.</p>
<p id="definition-1-3-2"><strong>Definition 1.3.2: Invertible Words</strong></p>
<p>Let <em>Œ±</em> be any Word in a Language <strong>L</strong>. Then the set of Invertible Words <strong>I</strong> is defined as the set of <em>Œ±</em> which satisfy the open formula,</p>
<div class="math notranslate nohighlight">
\[\alpha \in I \leftrightarrow \text{inv}(\alpha) \in L\]</div>
<p>‚àé</p>
<p>A Word <em>Œ±</em> will be referred to as <em>invertible</em> if it belongs to the class of Invertible Words.</p>
<p><a class="reference internal" href="#definition-1-3-2"><span class="std std-ref">Definition 1.3.2</span></a> is immediately employed to derive the following theorems.</p>
<p id="theorem-1-3-2"><strong>Theorem 1.3.2</strong> <span class="math notranslate nohighlight">\(\forall \alpha \in L: \alpha \in I \leftrightarrow \text{inv}(\alpha) \in I\)</span></p>
<p>(‚Üí) Assume <span class="math notranslate nohighlight">\(\alpha \in I\)</span>. By <a class="reference internal" href="#definition-1-3-2"><span class="std std-ref">Definition 1.3.2</span></a>,</p>
<div class="math notranslate nohighlight">
\[1. \quad \text{inv}(Œ±) \in L\]</div>
<p>Consider <em>inv(Œ±)</em>. To show that it‚Äôs invertible, it must be shown,</p>
<div class="math notranslate nohighlight">
\[2. \quad \text{inv}(\text{inv}(\alpha)) \in L.\]</div>
<p>By <a class="reference internal" href="#theorem-1-2-4"><span class="std std-ref">Theorem 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[3. \quad \text{inv}(\text{inv}(\alpha)) = \alpha\]</div>
<p>Since it is known <span class="math notranslate nohighlight">\(\alpha \in L\)</span>, it follows,</p>
<div class="math notranslate nohighlight">
\[4. \quad \text{inv}(\text{inv}(\alpha)) \in L\]</div>
<p>By the <a class="reference internal" href="#definition-1-3-2"><span class="std std-ref">Definition 1.3.2</span></a>,</p>
<div class="math notranslate nohighlight">
\[5. \quad \text{inv}(\alpha) \in I\]</div>
<p>Therefore, <em>inv(Œ±)</em> is also an Invertible Word.</p>
<p>(‚Üê) Assume <em>inv(Œ±)</em> is a Word in Language L and <span class="math notranslate nohighlight">\(inv(\alpha) \in I\)</span>. Then by <a class="reference internal" href="#definition-1-3-2"><span class="std std-ref">Definition 1.3.2</span></a>,</p>
<div class="math notranslate nohighlight">
\[1. \quad \text{inv}(\text{inv}(\alpha)) \in L\]</div>
<p>By <a class="reference internal" href="#theorem-1-2-4"><span class="std std-ref">Theorem 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[2. \quad \alpha \in L\]</div>
<p>To show <em>Œ±</em> is invertible, it must be shown <span class="math notranslate nohighlight">\(\text{inv}(\alpha) \in L\)</span>, but this is exactly what has been assumed, so it follows immediately.</p>
<p>Therefore, putting both directions of the equivalence together and generalizing over all Words in a Language,</p>
<div class="math notranslate nohighlight">
\[3. \quad \forall \alpha \in L: \alpha \in I ‚Üî \text{inv}(\alpha) \in I\]</div>
<p>‚àé</p>
<p id="theorem-1-3-3"><strong>Theorem 1.3.3</strong> <span class="math notranslate nohighlight">\(R \subseteq I\)</span></p>
<p>Assume <span class="math notranslate nohighlight">\(Œ± \in R\)</span>. By <a class="reference internal" href="#definition-1-3-2"><span class="std std-ref">Definition 1.3.2</span></a>,</p>
<div class="math notranslate nohighlight">
\[1. \quad \forall i \in N_{l(\alpha)}: \alpha[i] = \alpha[l(\alpha) - i + 1]\]</div>
<p>Let <span class="math notranslate nohighlight">\(\beta = inv(\alpha)\)</span>. By <a class="reference internal" href="#definition-1-2-4"><span class="std std-ref">Definition 1.2.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[2. \quad l(\beta) = l(\alpha)\]</div>
<div class="math notranslate nohighlight">
\[3. \quad \forall j \in N_{l(\alpha)}: \beta[j] = \alpha[l(\alpha) - j + 1]\]</div>
<p>Substituting step 1 into step 3,</p>
<div class="math notranslate nohighlight">
\[4. \quad \forall i \in N_{l(\alpha)}:  \beta[j] = \alpha[j]\]</div>
<p>Since both strings have the same length and the same Characters in the same order, by <a class="reference internal" href="#definition-1-1-4"><span class="std std-ref">Definition 1.1.4</span></a>,</p>
<div class="math notranslate nohighlight">
\[5. \quad \alpha = \beta = \text{inv}(\alpha)\]</div>
<p>By assumption, <em>Œ±</em> is a Word from Language <strong>L</strong> that belongs to <strong>R</strong>. From step 5, this implies <em>inv(Œ±)</em> is also part of the Language <strong>L</strong>. By <a class="reference internal" href="#definition-1-3-2"><span class="std std-ref">Definition 1.3.2</span></a>, this implies,</p>
<div class="math notranslate nohighlight">
\[6. \quad \alpha \in I\]</div>
<p>In other words,</p>
<div class="math notranslate nohighlight">
\[7. \quad \forall \alpha \in L: \alpha \in R \to \alpha \in I\]</div>
<p>But this is exactly the definition of the subset relation in set theory. Therefore,</p>
<div class="math notranslate nohighlight">
\[8. \quad R \subseteq I\]</div>
<p>‚àé</p>
<p>In the context of (potentially) infinite sets such as <strong>L</strong> and <strong>S</strong>, <em>‚Äúeven‚Äù</em> and <em>‚Äúodd‚Äù</em> refer to whether the set can be partitioned into two disjoint subsets of equal cardinality.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Even Cardinality: An infinite set has even cardinality if it can be put into a one-to-one correspondence with itself, with each element paired with a distinct element.</p></li>
<li><p>Odd Cardinality: An infinite set has odd cardinality if, after pairing each element with a distinct element, there is one element left over.</p></li>
</ol>
</div></blockquote>
<p>The set of non-reflective Invertible Words, <strong>I</strong> - <strong>R</strong> (where ‚Äú-‚Äù represents the operation of set differencing), always has even cardinality because each word can be paired with its distinct inverse. The overall cardinality of <strong>I</strong> then depends on whether the set of Reflective Words, <strong>R</strong>, adds an ‚Äúodd‚Äù element or not. This idea is captured in the next theorem.</p>
<p id="theorem-1-3-4"><strong>Theorem 1.3.4</strong> If <span class="math notranslate nohighlight">\(\lvert R \rvert\)</span> is even, then <span class="math notranslate nohighlight">\(\lvert I \rvert\)</span> is even. If <span class="math notranslate nohighlight">\(\lvert R \rvert\)</span> is odd, then <span class="math notranslate nohighlight">\(\lvert I \rvert\)</span> is odd.</p>
<p>Partition the set of Invertible Words, <strong>I</strong>, into two disjoint subsets,</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><strong>R</strong>: The set of Reflective Words.</p></li>
<li><p><strong>I</strong> - <strong>R</strong>: The set of Invertible Words that are not Reflective.</p></li>
</ol>
</div></blockquote>
<p>For every word <em>Œ±</em> in <span class="math notranslate nohighlight">\(I - R\)</span>, its inverse, <em>inv(Œ±)</em>, is also in <span class="math notranslate nohighlight">\(I - R\)</span>. Furthermore, they form a distinct pair <span class="math notranslate nohighlight">\((\alpha, \text{inv}(\alpha))\)</span>. This is because <em>Œ±</em> is invertible but not reflective, so <span class="math notranslate nohighlight">\(Œ± \neq \text{inv}(\alpha)\)</span>.</p>
<p>Since the elements of v can be grouped into distinct pairs, the cardinality <span class="math notranslate nohighlight">\(\lvert I - R \rvert\)</span> must be even.</p>
<p>The total number of Invertible Words is the sum of the number of Reflective Words and the number of Invertible Words that are not Reflective,</p>
<div class="math notranslate nohighlight">
\[3. \quad \lvert I \rvert = \lvert R \rvert + \lvert I - R \lvert\]</div>
<p>Let <span class="math notranslate nohighlight">\(\lvert R \rvert\)</span> be even. Since <span class="math notranslate nohighlight">\(\lvert I - R \rvert\)</span> is always even, and the sum of two even numbers is even, <span class="math notranslate nohighlight">\(\lvert I \rvert\)</span> must also be even.</p>
<p>Let <span class="math notranslate nohighlight">\(\lvert R \rvert\)</span> be odd. Since <span class="math notranslate nohighlight">\(\lvert I - R \rvert\)</span> is always even, and the sum of an odd number and an even number is odd, <span class="math notranslate nohighlight">\(\lvert I \rvert\)</span> must also be odd. ‚àé</p>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="01_introduction.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Palindromic Structures</p>
      </div>
    </a>
    <a class="right-next"
       href="03_corpora.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Section II: Corpora</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#section-i-i-strings">Section I.I: Strings</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#characters">Characters</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#concatenation">Concatenation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#string-length">String Length</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#containment">Containment</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#section-i-ii-words">Section I.II: Words</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#theorems">Theorems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#string-inversion">String Inversion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phrases">Phrases</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#section-i-iii-word-classes">Section I.III: Word Classes</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reflective-words">Reflective Words</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#invertible-words">Invertible Words</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Grant Moore
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      ¬© Copyright 2025, chinchalinchin industries.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>